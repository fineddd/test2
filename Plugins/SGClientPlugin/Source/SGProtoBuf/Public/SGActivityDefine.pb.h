// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SGActivityDefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SGActivityDefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SGActivityDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SGActivityDefine_2eproto SGPROTOBUF_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct SGPROTOBUF_API TableStruct_SGActivityDefine_2eproto {
  static const uint32_t offsets[];
};
SGPROTOBUF_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SGActivityDefine_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace SGActivityDefine {

enum EActivityType : int {
  ACTIVITY_ASSEMBLE = 1,
  ACTIVITY_SEVEN_DAY = 2,
  ACTIVITY_SIGN_IN = 3,
  ACTIVITY_SPRINT_RANK = 4,
  ACTIVITY_ALLIANCE_RANK = 5,
  ACTIVITY_DAILY_SIGN_IN = 6,
  ACTIVITY_COMMANDER = 7,
  ACTIVITY_REPEATED_PAY = 9,
  ACTIVITY_ROULETTE = 10,
  ACTIVITY_RED_PACKET = 11,
  ACTIVITY_DOOMSDAY = 12,
  ACTIVITY_SHELTER_BUILD = 13,
  ACTIVITY_TIMED_RACE = 14,
  ACTIVITY_MOBILIZATION = 18,
  ACTIVITY_MOBILIZATION_PREVIEW = 19,
  ACTIVITY_CYCLE_TASK = 21,
  ACTIVITY_TIME_LIMIT_MATCH = 22,
  ACTIVITY_ALLIANCE_BOSS = 25,
  ACTIVITY_BATTLEROYALE = 26,
  ACTIVITY_ASSEMBLE_TASK = 27,
  ACTIVITY_ALLIANCE_DUEL = 29,
  ACTIVITY_HERO_TRIAL = 30,
  ACTIVITY_ALLIANCE_DUEL_PREVIEW = 31,
  ACTIVITY_SHOWONLY = 98,
  ACTIVITY_CALENDAR = 99,
  CHARGE_ACTIVITY_CHARGE_BAG = 101,
  CHARGE_ACTIVITY_CHARGE_BAGSP = 102,
  CHARGE_ACTIVITY_MOON_CARD = 103,
  CHARGE_ACTIVITY_SUBSCRIBE = 104,
  CHARGE_ACTIVITY_BATTLE_PASS = 105,
  CHARGE_CUSTOM_CHARGE = 106,
  CHARGE_ACTIVITY_REPAY = 107,
  CHARGE_ACTIVITY_DAILY_PACK = 108,
  CHARGE_ACTIVITY_BASIC_CURRENCY = 109,
  CHARGE_TITLE_CHARGE_BAG = 110,
  CHARGE_ULTIMATE_CHARGE_BAG = 111,
  CHARGE_GROWTH_FUND = 120,
  CHARGE_FIRST_CHARGE = 121,
  CHARGE_ACTIVITY_CHARGE_WEEKLY = 122,
  CHARGE_ACTIVITY_NEW_SUBSCRIBE = 123,
  ACTIVITY_FREE_PURCHASE = 124,
  ACTIVITY_COME_BACK = 125,
  ACTIVITY_BATTLE_PASS_NEW = 126,
  ACTIVITY_WORLD_BOSS = 127,
  CHARGE_ACTIVITY_COUNT = 128,
  CHARGE_ACTIVITY_TREASURE_MARKET = 129,
  ACTIVITY_HERO_MANUAL = 130,
  ACTIVITY_SHARANNA_FLOP = 131,
  ACTIVITY_SHARANNA_PUZZLE = 132,
  ACTIVITY_SHARANNA_GIFT = 133,
  WEEKLYPAY_EVENTS_MONSTER = 1001,
  WEEKLYPAY_EVENTS_TASK = 1002,
  WEEKLYPAY_EVENTS_SHOP = 1003,
  WEEKLYPAY_EVENTS_NEW = 2001
};
SGPROTOBUF_API bool EActivityType_IsValid(int value);
constexpr EActivityType EActivityType_MIN = ACTIVITY_ASSEMBLE;
constexpr EActivityType EActivityType_MAX = WEEKLYPAY_EVENTS_NEW;
constexpr int EActivityType_ARRAYSIZE = EActivityType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EActivityType_descriptor();
template<typename T>
inline const std::string& EActivityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EActivityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EActivityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EActivityType_descriptor(), enum_t_value);
}
inline bool EActivityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EActivityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EActivityType>(
    EActivityType_descriptor(), name, value);
}
enum EActivityEvent : int {
  EACTIVITY_PLAYER_ONLINE = 1,
  EACTIVITY_CASTLE_LEVEL = 2,
  EACTIVITY_KILL_MONSTER_TOP_LV = 3,
  EACTIVITY_CARUPGRADE_POWER = 4,
  EACTIVITY_HERO_TOTAL_POWER = 5,
  EACTIVITY_HERO_POWER_1 = 6,
  EACTIVITY_HERO_POWER_2 = 7,
  EACTIVITY_HERO_POWER_3 = 8,
  EACTIVITY_ALLIANCE_POWER = 9,
  EACTIVITY_PERSONAL_POWER = 10,
  EACTIVITY_TRAIN_SOLDIER = 11,
  EACTIVITY_KILL_MONSTER = 12,
  EACTIVITY_GATHER_RESOURCE = 13,
  EACTIVITY_TECH_BUILDING_ADD_POWER = 14,
  EACTIVITY_PVP_KILL_SOLDIER = 15,
  EACTIVITY_DAILLY_REFRESH = 16,
  EACTIVITY_WEEKLY_REFRESH = 17,
  EACTIVITY_MONTHLY_REFRESH = 18,
  EACTIVITY_AFTER_CHARGE_EVENT = 19,
  EACTIVITY_GAME_CITY_INIT = 20,
  EACTIVITY_SETTLE_EVENT = 21,
  EACTIVITY_CLEAR_PLAYER_DATA = 22,
  EACTIVITY_ALL_MODULE_POWER = 23,
  EACTIVITY_ENERGY_COST = 24,
  EACTIVITY_SPEED_UP_BY_ITEM = 25,
  EACTIVITY_SPEED_UP_ANY = 26,
  EACTIVITY_CHARGE_COUNT = 27,
  EACTIVITY_TASKTYPE_UPDATE = 28,
  EACTIVITY_HERO_UP_STAR_BY_ITEM = 29,
  EACTIVITY_CAR_UP_STAR_BY_ITEM = 30,
  EACTIVITY_CAR_UP_STAR_ANY = 31,
  EACTIVITY_USE_CAR_EXP_ITEM = 32,
  EACTIVITY_HERO_UP_EQUIP_BY_ITEM = 33,
  EACTIVITY_HERO_UP_EQUIP_ANY = 34,
  EACTIVITY_BEFORE_MIGRATE = 35,
  EACTIVITY_AFTER_MIGRATE = 36,
  EACTIVITY_COMMANDER_ACTIVITY_POWER = 37,
  EACTIVITY_ROTATE_ROULETTE = 38,
  EACTIVITY_BUILDING_POWER = 39,
  EACTIVITY_TECH_POWER = 40,
  EACTIVITY_INCIDENT = 41,
  EACTIVITY_KILL_ASSEMBLE_MONSTER = 42,
  EACTIVITY_TIME_LIMIT_MATCH_ITEM = 43,
  EACTIVITY_TIME_LIMIT_MATCH_SETTLE = 44,
  EACTIVITY_PROPERTY_INIT = 45,
  EACTIVITY_STUDY_TECH = 46
};
SGPROTOBUF_API bool EActivityEvent_IsValid(int value);
constexpr EActivityEvent EActivityEvent_MIN = EACTIVITY_PLAYER_ONLINE;
constexpr EActivityEvent EActivityEvent_MAX = EACTIVITY_STUDY_TECH;
constexpr int EActivityEvent_ARRAYSIZE = EActivityEvent_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EActivityEvent_descriptor();
template<typename T>
inline const std::string& EActivityEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EActivityEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EActivityEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EActivityEvent_descriptor(), enum_t_value);
}
inline bool EActivityEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EActivityEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EActivityEvent>(
    EActivityEvent_descriptor(), name, value);
}
enum EActivityCommanderIntegral : int {
  TRAIN_SOLDIER = 1,
  KILL_MONSTER = 2,
  GATHER_RESOURCE = 3,
  PERSONAL_POWER = 4,
  TECH_BUILDING_UPLV = 5,
  PVP_KILL_SOLDIER = 6,
  SPEED_UP_BY_ITEM = 8,
  HERO_UP_STAR_BY_ITEM = 9,
  CAR_UP_STAR_ANY = 10,
  CAR_UP_STAR_BY_ITEM = 11,
  USE_CAR_EXP_ITEM = 12,
  HERO_UP_EQUIP_ANY = 13,
  HERO_UP_EQUIP_BY_ITEM = 14,
  SPEED_UP_ANY = 15,
  ROTATE_ROULETTE = 16,
  BUILDING_POWER = 17,
  TECH_POWER = 18,
  INCIDENT = 19
};
SGPROTOBUF_API bool EActivityCommanderIntegral_IsValid(int value);
constexpr EActivityCommanderIntegral EActivityCommanderIntegral_MIN = TRAIN_SOLDIER;
constexpr EActivityCommanderIntegral EActivityCommanderIntegral_MAX = INCIDENT;
constexpr int EActivityCommanderIntegral_ARRAYSIZE = EActivityCommanderIntegral_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EActivityCommanderIntegral_descriptor();
template<typename T>
inline const std::string& EActivityCommanderIntegral_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EActivityCommanderIntegral>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EActivityCommanderIntegral_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EActivityCommanderIntegral_descriptor(), enum_t_value);
}
inline bool EActivityCommanderIntegral_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EActivityCommanderIntegral* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EActivityCommanderIntegral>(
    EActivityCommanderIntegral_descriptor(), name, value);
}
enum EChargeBagType : int {
  CBT_FREE_CHARGE_BAG = 3
};
SGPROTOBUF_API bool EChargeBagType_IsValid(int value);
constexpr EChargeBagType EChargeBagType_MIN = CBT_FREE_CHARGE_BAG;
constexpr EChargeBagType EChargeBagType_MAX = CBT_FREE_CHARGE_BAG;
constexpr int EChargeBagType_ARRAYSIZE = EChargeBagType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EChargeBagType_descriptor();
template<typename T>
inline const std::string& EChargeBagType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EChargeBagType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EChargeBagType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EChargeBagType_descriptor(), enum_t_value);
}
inline bool EChargeBagType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EChargeBagType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EChargeBagType>(
    EChargeBagType_descriptor(), name, value);
}
enum EPowerModuleType : int {
  PMT_None = 0,
  PMT_Hero = 204000001,
  PMT_CityBuild = 204000103,
  PMT_Tech = 204000204,
  PMT_Soldier = 204000305,
  PMT_Car = 204000406
};
SGPROTOBUF_API bool EPowerModuleType_IsValid(int value);
constexpr EPowerModuleType EPowerModuleType_MIN = PMT_None;
constexpr EPowerModuleType EPowerModuleType_MAX = PMT_Car;
constexpr int EPowerModuleType_ARRAYSIZE = EPowerModuleType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPowerModuleType_descriptor();
template<typename T>
inline const std::string& EPowerModuleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPowerModuleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPowerModuleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPowerModuleType_descriptor(), enum_t_value);
}
inline bool EPowerModuleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPowerModuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPowerModuleType>(
    EPowerModuleType_descriptor(), name, value);
}
enum EActivityTimeType : int {
  EACTIVITY_TIME_NONE = 0,
  EACTIVITY_TIME_PERMANENT = 1,
  EACTIVITY_TIME_LIMIT_TIME = 2,
  EACTIVITY_TIME_SERVER_OPEN = 3,
  EACTIVITY_TIME_CIRCLE = 4,
  EACTIVITY_TIME_TRIGGER = 5,
  EACTIVITY_TIME_WEEK = 6,
  EACTIVITY_TIME_LOOP = 7
};
SGPROTOBUF_API bool EActivityTimeType_IsValid(int value);
constexpr EActivityTimeType EActivityTimeType_MIN = EACTIVITY_TIME_NONE;
constexpr EActivityTimeType EActivityTimeType_MAX = EACTIVITY_TIME_LOOP;
constexpr int EActivityTimeType_ARRAYSIZE = EActivityTimeType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EActivityTimeType_descriptor();
template<typename T>
inline const std::string& EActivityTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EActivityTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EActivityTimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EActivityTimeType_descriptor(), enum_t_value);
}
inline bool EActivityTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EActivityTimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EActivityTimeType>(
    EActivityTimeType_descriptor(), name, value);
}
enum EActivityBattlePassAction : int {
  ACTION_SPEED_UP_FOR_BUILDING = 1,
  ACTION_SPEED_UP_FOR_TECH = 2,
  ACTION_SPEED_UP_FOR_TRAIN_SOLDIER = 3,
  ACTION_KILL_MONSTER = 4
};
SGPROTOBUF_API bool EActivityBattlePassAction_IsValid(int value);
constexpr EActivityBattlePassAction EActivityBattlePassAction_MIN = ACTION_SPEED_UP_FOR_BUILDING;
constexpr EActivityBattlePassAction EActivityBattlePassAction_MAX = ACTION_KILL_MONSTER;
constexpr int EActivityBattlePassAction_ARRAYSIZE = EActivityBattlePassAction_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EActivityBattlePassAction_descriptor();
template<typename T>
inline const std::string& EActivityBattlePassAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EActivityBattlePassAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EActivityBattlePassAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EActivityBattlePassAction_descriptor(), enum_t_value);
}
inline bool EActivityBattlePassAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EActivityBattlePassAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EActivityBattlePassAction>(
    EActivityBattlePassAction_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace SGActivityDefine

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SGActivityDefine::EActivityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EActivityType>() {
  return ::SGActivityDefine::EActivityType_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EActivityEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EActivityEvent>() {
  return ::SGActivityDefine::EActivityEvent_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EActivityCommanderIntegral> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EActivityCommanderIntegral>() {
  return ::SGActivityDefine::EActivityCommanderIntegral_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EChargeBagType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EChargeBagType>() {
  return ::SGActivityDefine::EChargeBagType_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EPowerModuleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EPowerModuleType>() {
  return ::SGActivityDefine::EPowerModuleType_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EActivityTimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EActivityTimeType>() {
  return ::SGActivityDefine::EActivityTimeType_descriptor();
}
template <> struct is_proto_enum< ::SGActivityDefine::EActivityBattlePassAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGActivityDefine::EActivityBattlePassAction>() {
  return ::SGActivityDefine::EActivityBattlePassAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SGActivityDefine_2eproto
