// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SGDefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SGDefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SGDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SGDefine_2eproto SGPROTOBUF_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct SGPROTOBUF_API TableStruct_SGDefine_2eproto {
  static const uint32_t offsets[];
};
SGPROTOBUF_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SGDefine_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace SGDefine {

enum ZKServerType : int {
  ZK_SERVER_TYPE_IN_BIGAREA = 0,
  ZK_SERVER_TYPE_OUT_BIGAREA = 1
};
SGPROTOBUF_API bool ZKServerType_IsValid(int value);
constexpr ZKServerType ZKServerType_MIN = ZK_SERVER_TYPE_IN_BIGAREA;
constexpr ZKServerType ZKServerType_MAX = ZK_SERVER_TYPE_OUT_BIGAREA;
constexpr int ZKServerType_ARRAYSIZE = ZKServerType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ZKServerType_descriptor();
template<typename T>
inline const std::string& ZKServerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ZKServerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ZKServerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ZKServerType_descriptor(), enum_t_value);
}
inline bool ZKServerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ZKServerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ZKServerType>(
    ZKServerType_descriptor(), name, value);
}
enum server_type : int {
  SERVER_TYPE_SELF = 0,
  SERVER_TYPE_CLIENT = 1,
  SERVER_TYPE_WEBSDK = 4,
  SERVER_TYPE_GMIP = 5,
  SERVER_TYPE_CONFIG = 6,
  SERVER_TYPE_MASTER = 7,
  SERVER_TYPE_LOGIN = 8,
  SERVER_TYPE_GATEWAY = 9,
  SERVER_TYPE_DB = 10,
  SERVER_TYPE_GAME = 11,
  SERVER_TYPE_PUBLIC = 12,
  SERVER_TYPE_GUILD = 13,
  SERVER_TYPE_MAIL = 14,
  SERVER_TYPE_CHAT = 15,
  SERVER_TYPE_SECURITY = 16,
  SERVER_TYPE_DUNGEONS = 17,
  SERVER_TYPE_HTTP = 22,
  SERVER_TYPE_ROUTER = 23,
  SERVER_TYPE_MATCH = 24,
  SERVER_TYPE_AUTH = 25,
  SERVER_TYPE_DATACENTER = 26,
  SERVER_TYPE_FRIEND = 27,
  SERVER_TYPE_GUARD = 28,
  SERVER_TYPE_TEST = 29,
  SERVER_TYPE_SCENCE = 30,
  SERVER_TYPE_SCENCECLONE = 31,
  SERVER_TYPE_ALLIANCE = 32,
  SERVER_TYPE_CROSS = 33,
  SERVER_TYPE_CROSS_GATE = 34,
  SERVER_TYPE_CROSS_SCENCE = 35,
  SERVER_TYPE_END = 36
};
SGPROTOBUF_API bool server_type_IsValid(int value);
constexpr server_type server_type_MIN = SERVER_TYPE_SELF;
constexpr server_type server_type_MAX = SERVER_TYPE_END;
constexpr int server_type_ARRAYSIZE = server_type_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* server_type_descriptor();
template<typename T>
inline const std::string& server_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, server_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function server_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    server_type_descriptor(), enum_t_value);
}
inline bool server_type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, server_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<server_type>(
    server_type_descriptor(), name, value);
}
enum ItemResourceType : int {
  ITEM_RESOURCE_TYPE_NONE = 0,
  ITEM_RESOURCE_TYPE_CURRENCY = 1,
  ITEM_RESOURCE_TYPE_ADDSPEED = 2,
  ITEM_RESOURCE_TYPE_HERO_CHIP = 3,
  ITEM_RESOURCE_TYPE_HERO = 4,
  ITEM_RESOURCE_TYPE_HEROE_GROWUP = 5,
  ITEM_RESOURCE_TYPE_TREASURE_BOX = 6,
  ITEM_RESOURCE_TYPE_CURRENCY_IN_BAG = 7,
  ITEM_RESOURCE_TYPE_CITY_MOVE = 8,
  ITEM_RESOURCE_TYPE_RECRUIT = 9,
  ITEM_RESOURCE_TYPE_SOLDIER_ITEM = 10,
  ITEM_RESOURCE_TYPE_RECRUIT_CREDIT = 11,
  ITEM_RESOURCE_TYPE_SHOW_TIPS = 12,
  ITEM_RESOURCE_TYPE_DRESS_UP = 13,
  ITEM_RESOURCE_TYPE_CHANGE_NAME = 14,
  ITEM_RESOURCE_TYPE_ADDBUFF = 15,
  ITEM_RESOURCE_TYPE_CALL_MONSTER = 16,
  ITEM_RESOURCE_TYPE_ALLIANCE = 17,
  ITEM_RESOURCE_TYPE_CITY_GROWUP = 18,
  ITEM_RESOURCE_TYPE_EQUIP_MATERIAL = 19,
  ITEM_RESOURCE_TYPE_CAR_UPGRA = 20,
  ITEM_RESOURCE_TYPE_CAR_STAR = 21,
  ITEM_RESOURCE_TYPE_VIPPOINT = 22,
  ITEM_RESOURCE_TYPE_NOTE = 23,
  ITEM_RESOURCE_TYPE_UNLOCK_WORKER = 24,
  ITEM_RESOURCE_TYPE_UPGRADE_BUILDING = 25,
  ITEM_RESOURCE_TYPE_SHELTER_UNLOCK = 26,
  ITEM_RESOURCE_TYPE_RED_PACKET = 27,
  ITEM_RESOURCE_TYPE_CAR_ACTIVE = 28,
  ITEM_RESOURCE_TYPE_NPC_DISPATCH = 29,
  ITEM_RESOURCE_TYPE_ALLIANCE_GIFT = 30,
  ITEM_RESOURCE_TYPE_HERO_EQUIP = 31,
  ITEM_RESOURCE_TYPE_AUTO_OPEN_BOX = 32,
  ITEM_RESOURCE_TYPE_BATTLE_PASS_SCORE = 33,
  ITEM_RESOURCE_TYPE_MIGRATE = 34,
  ITEM_RESOURCE_TYPE_DUNGEONLISTREWARD = 35,
  ITEM_RESOURCE_TYPE_FACILITY = 36,
  ITEM_RESOURCE_TYPE_SKIN = 37,
  ITEM_RESOURCE_TYPE_FURNITURE_COST = 38,
  ITEM_RESOURCE_TYPE_DEVICE = 39,
  ITEM_RESOURCE_TYPE_DAILY_SCORE = 40,
  ITEM_RESOURCE_TYPE_TIME_LIMIT_MATCH = 41,
  ITEM_RESOURCE_TYPE_ESCORT_ITEM = 42,
  ITEM_RESOURCE_TYPE_LEVEL_BOX = 43,
  ITEM_RESOURCE_TYPE_LEGEND = 44,
  ITEM_RESOURCE_TYPE_LEGEND_CHIP = 45,
  ITEM_RESOURCE_TYPE_APC = 46,
  ITEM_RESOURCE_VIP_TIME = 47,
  ITEM_RESOURCE_VIP_TIME_POINT = 48,
  ITEM_RESOURCE_GLORY_SCORE = 49,
  ITEM_RESOURCE_TYPE_RESIDENT = 50,
  ITEM_RESOURCE_TYPE_RESIDENT_CHIP = 51,
  ITEM_RESOURCE_TYPE_EMOJI = 52,
  ITEM_RESOURCE_TYPE_DECORATION = 53,
  ITEM_RESOURCE_TYPE_END = 54
};
SGPROTOBUF_API bool ItemResourceType_IsValid(int value);
constexpr ItemResourceType ItemResourceType_MIN = ITEM_RESOURCE_TYPE_NONE;
constexpr ItemResourceType ItemResourceType_MAX = ITEM_RESOURCE_TYPE_END;
constexpr int ItemResourceType_ARRAYSIZE = ItemResourceType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemResourceType_descriptor();
template<typename T>
inline const std::string& ItemResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemResourceType_descriptor(), enum_t_value);
}
inline bool ItemResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemResourceType>(
    ItemResourceType_descriptor(), name, value);
}
enum HeroBelongType : int {
  HERO_BELONG_TYPE_NONE = 0,
  HERO_BELONG_TYPE_PLAYER = 1,
  HERO_BELONG_TYPE_MONSTER = 2,
  HERO_BELONG_TYPE_SPECIAL = 3
};
SGPROTOBUF_API bool HeroBelongType_IsValid(int value);
constexpr HeroBelongType HeroBelongType_MIN = HERO_BELONG_TYPE_NONE;
constexpr HeroBelongType HeroBelongType_MAX = HERO_BELONG_TYPE_SPECIAL;
constexpr int HeroBelongType_ARRAYSIZE = HeroBelongType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HeroBelongType_descriptor();
template<typename T>
inline const std::string& HeroBelongType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeroBelongType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeroBelongType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HeroBelongType_descriptor(), enum_t_value);
}
inline bool HeroBelongType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeroBelongType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HeroBelongType>(
    HeroBelongType_descriptor(), name, value);
}
enum ItemSubType : int {
  ITEM_SUB_TYPE_NONE = 0,
  ITEM_SUB_TYPE_GOLD = 10000,
  ITEM_SUB_TYPE_ONE_OIL = 10001,
  ITEM_SUB_TYPE_TWO_IRON = 10002,
  ITEM_SUB_TYPE_THREE_FOOD = 10003,
  ITEM_SUB_TYPE_FOUR_WATER = 10004,
  ITEM_SUB_TYPE_POINTS = 10005,
  ITEM_SUB_TYPE_PAY_GOLD = 10006,
  ITEM_SUB_TYPE_DUNGEON = 10007,
  ITEM_SUB_TYPE_ARENA = 10008,
  ITEM_SUB_TYPE_ORDER = 10009,
  ITEM_SUB_TYPE_DOLLAR = 10010,
  ITEM_SUB_TYPE_MIN_GAME_ENERGY = 10012,
  ITEM_SUB_TYPE_RESCUE = 10013,
  ITEM_SUB_TYPE_HERO_COMMON_EXP = 10014,
  ITEM_SUB_SHUGUANGZHILU_SCORE = 10015,
  ITEM_SUB_TYPE_BUILDSPEED = 20005,
  ITEM_SUB_TYPE_STUDYSPEED = 20006,
  ITEM_SUB_TYPE_CURESPEED = 20007,
  ITEM_SUB_TYPE_TRAINSPEED = 20008,
  ITEM_SUB_TYPE_COMONSPEED = 20009,
  ITEM_SUB_TYPE_VIPPOINT = 22001,
  ITEM_SUB_TYPE_NOTE = 23000,
  ITEM_SUB_TYPE_UNLOCK_WORKER = 24001,
  ITEM_SUB_TYPE_UPGRADE_BUILDING = 25000,
  ITEM_SUB_TYPE_SHELTER_UNLOCK_1 = 26001,
  ITEM_SUB_TYPE_SHELTER_UNLOCK_2 = 26002,
  ITEM_SUB_TYPE_NPC_DISPATCH = 29001,
  ITEM_SUB_TYPE_ALLIANCE_GIFT = 30001,
  ITEM_SUB_TYPE_HEROE_CHIP = 30009,
  ITEM_SUB_TYPE_COMMON_HEROE_CHIP = 30011,
  ITEM_SUB_TYPE_HERO_EQUIP = 31001,
  ITEM_SUB_TYPE_HERO_AUTO = 40010,
  ITEM_SUB_TYPE_KNOWLEDGE = 50008,
  ITEM_SUB_TYPE_SKILLBOOK = 50009,
  ITEM_SUB_TYPE_TALENT_RESET = 50010,
  ITEM_SUB_TYPE_ALLIANCE_BOX = 60007,
  ITEM_SUB_TREASURE_BOX_NORMAL = 60008,
  ITEM_SUB_TREASURE_BOX_USER_CHOOSE = 60009,
  ITEM_SUB_TREASURE_BOX_RANDOM = 60010,
  ITEM_SUB_TYPE_STAMINA = 70001,
  ITEM_SUB_CITY_MOVE_SENIOR = 80001,
  ITEM_SUB_CITY_MOVE_RANDOM = 80002,
  ITEM_SUB_CITY_MOVE_ALLIANCE = 80003,
  ITEM_SUB_CITY_MOVE_NEW_HAND = 80004,
  ITEM_SUB_CITY_MOVE_ALLIANCE_ROOKIE = 80005,
  ITEM_SUB_CITY_MOVE_ALLIANCE_LEADER = 80006,
  ITEM_SUB_TYPE_RECRUIT = 90001,
  ITEM_SUB_TYPE_SOLDIER_ITEM = 100001,
  ITEM_SUB_TYPE_RECRUIT_CREDIT_1 = 110001,
  ITEM_SUB_TYPE_RECRUIT_CREDIT_2 = 110002,
  ITEM_SUB_TYPE_SHOW_TIPS = 120001,
  ITEM_SUB_TYPE_DRESS_UP_1 = 130001,
  ITEM_SUB_TYPE_DRESS_UP_2 = 130002,
  ITEM_SUB_TYPE_CHANGE_NAME = 140001,
  ITEM_SUB_TYPE_CHANGE_ALLIANCE_NAME = 140002,
  ITEM_SUB_TYPE_ADDBUFF = 150000,
  ITEM_SUB_TYPE_CALL_MONSTER = 160001,
  ITEM_SUB_TYPE_ALLIANCE_FOOD = 170001,
  ITEM_SUB_TYPE_ALLIANCE_WOOD = 170002,
  ITEM_SUB_TYPE_ALLIANCE_IRON = 170003,
  ITEM_SUB_TYPE_ALLIANCE_OIL = 170004,
  ITEM_SUB_TYPE_CITY_GROWUP = 180000,
  ITEM_SUB_TYPE_EQUIP_MATERIAL = 190000,
  ITEM_SUB_TYPE_CAR_UPGRA = 200000,
  ITEM_SUB_TYPE_CAR_STAR = 210000,
  ITEM_SUB_TYPE_VIPPOINT_0 = 220000,
  ITEM_SUB_TYPE_RED_PACKET = 270001,
  ITEM_SUB_TYPE_AUTO_OPEN_BOX = 320001,
  ITEM_SUB_TYPE_BATTLE_PASS_SCORE = 330001,
  ITEM_SUB_TYPE_GETDUNGEONREWARD = 350001,
  ITEM_SUB_TYPE_SKIN = 380001,
  ITEM_SUB_TYPE_LEGEND = 420001,
  ITEM_SUB_TYPE_LEGEND_CHIP = 430001,
  ITEM_SUB_TYPE_APC_LEVELUP = 460001,
  ITEM_SUB_TYPE_APC_PART_LEVELUP = 460002,
  ITEM_SUB_TYPE_APC_PART_LEVELUP2 = 460003,
  ITEM_SUB_TYPE_RESIDENT = 500001,
  ITEM_SUB_TYPE_RESIDENT_CHIP = 510001,
  ITEM_SUB_TYPE_DECORATION = 530001,
  ITEM_SUB_TYPE_DECORATION_GENERAL_FRAGMENT = 530002,
  ITEM_SUB_TYPE_DECORATION_SPECIFIC_FRAGMENT = 530003
};
SGPROTOBUF_API bool ItemSubType_IsValid(int value);
constexpr ItemSubType ItemSubType_MIN = ITEM_SUB_TYPE_NONE;
constexpr ItemSubType ItemSubType_MAX = ITEM_SUB_TYPE_DECORATION_SPECIFIC_FRAGMENT;
constexpr int ItemSubType_ARRAYSIZE = ItemSubType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemSubType_descriptor();
template<typename T>
inline const std::string& ItemSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemSubType_descriptor(), enum_t_value);
}
inline bool ItemSubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemSubType>(
    ItemSubType_descriptor(), name, value);
}
enum RewardSourceType : int {
  REWARD_SOURCE_TYPE_NONE = 0,
  REWARD_SOURCE_TYPE_FIGHT_PLUNDER = 1,
  REWARD_SOURCE_TYPE_FIGHT_FIRST_BLOOD = 2,
  REWARD_SOURCE_TYPE_FIGHT_NORMAL = 3,
  REWARD_SOURCE_TYPE_FIGHT_ASSEMBLE = 4,
  REWARD_SOURCE_TYPE_RESOURCE_GATHER = 5,
  REWARD_SOURCE_TYPE_RECRUIT = 6,
  REWARD_SOURCE_TYPE_VIP_LEVEL = 7,
  REWARD_SOURCE_TYPE_LIMIT_SHOP = 8,
  REWARD_SOURCE_TYPE_ITEM_SHOP = 9,
  REWARD_SOURCE_TYPE_COMMANDER_BUFF = 10,
  REWARD_SOURCE_TYPE_CAMPAIGN_GET = 11,
  REWARD_SOURCE_TYPE_RESOURCE_BUY = 12,
  REWARD_SOURCE_TYPE_BUILDING_UPGRADE = 13,
  REWARD_SOURCE_TYPE_TRAIN_SOLDIER = 14,
  REWARD_SOURCE_TYPE_PROMOTE_SOLDIER = 15,
  REWARD_SOURCE_TYPE_STUDY_TECH = 16,
  REWARD_SOURCE_TYPE_SHOP_REFRESH = 17,
  REWARD_SOURCE_TYPE_BUY_STAMINA = 18,
  REWARD_SOURCE_TYPE_SHOP_BUY = 19,
  REWARD_SOURCE_TYPE_ALLIANCE_MOBILIZATION_BUY = 20,
  REWARD_SOURCE_TYPE_CHANGE_NAME = 21,
  REWARD_SOURCE_TYPE_FIRE = 22,
  REWARD_SOURCE_TYPE_GOLD_BANK_SAVE = 23,
  REWARD_SOURCE_TYPE_ALLIANCE_DONATE = 24,
  REWARD_SOURCE_TYPE_ALLIANCE_FREE_BOX = 25,
  REWARD_SOURCE_TYPE_ALLIANCE_PAY_BOX = 26,
  REWARD_SOURCE_TYPE_ALLIANCE_HONOR_BOX = 27,
  REWARD_SOURCE_TYPE_ACTIVITY_COST_GOLD = 28,
  REWARD_SOURCE_TYPE_ALLIANCE_BOSS = 29,
  REWARD_SOURCE_TYPE_CAMPAIGN_HANGUP = 30,
  REWARD_SOURCE_TYPE_ROULETTE = 31,
  REWARD_SOURCE_TYPE_SPEEDUP_BY_GOLD = 32,
  REWARD_SOURCE_TYPE_SPEEDUP_USE_ITEMS = 33,
  REWARD_SOURCE_TYPE_SPEEDUP_BUY_ITEM = 34,
  REWARD_SOURCE_TYPE_DUNGEON_FIRST_PASS = 35,
  REWARD_SOURCE_TYPE_EXPLORE_EVENT_REWARD = 36,
  REWARD_SOURCE_TYPE_CAR_UPGRADE = 37,
  REWARD_SOURCE_TYPE_CAR_STAR = 38,
  REWARD_SOURCE_TYPE_NPC_LEVELUP = 39,
  REWARD_SOURCE_TYPE_VIP_FREE_PACK = 40,
  REWARD_SOURCE_TYPE_ASSEMBLE_ACTIVITY = 41,
  REWARD_SOURCE_TYPE_CURE_SOLDIER = 42,
  REWARD_SOURCE_TYPE_RESOURCE_FACTORYS = 43,
  REWARD_SOURCE_TYPE_CHAPTER_TASK = 44,
  REWARD_SOURCE_TYPE_MAIN_TASK = 45,
  REWARD_SOURCE_TYPE_BRANCH_TASK = 46,
  REWARD_SOURCE_TYPE_MAP_INCIDENT = 47,
  REWARD_SOURCE_TYPE_MAIL_REWARD = 48,
  REWARD_SOURCE_TYPE_CHARGE_PAY = 52,
  REWARD_SOURCE_TYPE_HERO_EXP = 53,
  REWARD_SOURCE_TYPE_HERO_STARUP = 54,
  REWARD_SOURCE_TYPE_EQUIP_UPGRADE = 55,
  REWARD_SOURCE_TYPE_EQUIP_RISE = 56,
  REWARD_SOURCE_TYPE_EQUIP_RECYCLE = 57,
  REWARD_SOURCE_TYPE_HERO_STORY = 58,
  REWARD_SOURCE_TYPE_GOLD_BANK_GET = 59,
  REWARD_SOURCE_TYPE_CITY_MOVE = 60,
  REWARD_SOURCE_TYPE_CREATE_ALLIANCE = 61,
  REWARD_SOURCE_BATTLE_PASS = 62,
  REWARD_SOURCE_REPEAT_PAY = 63,
  REWARD_SOURCE_ROULETTE_ACTIVITY = 64,
  REWARD_SOURCE_WEEKLY_PAY_EVENTS_SHOP = 65,
  REWARD_SOURCE_ACTIVITY_FREE_REWARD = 66,
  REWARD_SOURCE_BTR_ACTIVITY_DUNGEON = 67,
  REWARD_SOURCE_BTR_ACTIVITY_TASK = 68,
  REWARD_SOURCE_BTR_ACTIVITY_ROULETTE = 69,
  REWARD_SOURCE_BTR_ACTIVITY_CLEAR = 70,
  REWARD_SOURCE_BTR_ACTIVITY_EXCHANGE = 71,
  REWARD_SOURCE_ACTIVITY_NEWSUBSCRIBE = 72,
  REWARD_SOURCE_BUILDING_FACILITY = 73,
  REWARD_SOURCE_TYPE_AFFAIR_REWARD = 74,
  REWARD_SOURCE_TYPE_DECREE = 75,
  REWARD_SOURCE_TYPE_AFFAIR_SECTION = 76,
  REWARD_SOURCE_FREE_PURCHASE = 77,
  REWARD_SOURCE_CREATE_FURNITURE = 78,
  REWARD_SOURCE_UPGRADE_FURNITURE = 79,
  REWARD_SOURCE_METEOR_REWARD = 80,
  REWARD_SOURCE_SMALL_GAME_ATTACK = 81,
  REWARD_SOURCE_DAILY_TASK = 82,
  REWARD_SOURCE_HERO_DISPATCH = 83,
  REWARD_SOURCE_HERO_DISPATCH_HELP = 84,
  REWARD_SOURCE_HERO_DISPATCH_ROB = 85,
  REWARD_SOURCE_APC_LEVELUP = 86,
  REWARD_SOURCE_APC_PART_LEVELUP = 87,
  REWARD_SOURCE_TYPE_CHANGE_GENDER = 88,
  REWARD_SOURCE_TYPE_HERO_MANUAL = 89,
  REWARD_SOURCE_TYPE_VIP_TIME = 90,
  REWARD_SOURCE_TYPE_SKILLBOOK_EXCHANGE = 91,
  REWARD_SOURCE_TYPE_ACTIVITY_SHARANNA_PUZZLE = 92,
  REWARD_SOURCE_TYPE_ACTIVITY_SHARANNA_FLOP = 93,
  REWARD_SOURCE_TYPE_ACTIVITY_CUSTOM_BAG = 94,
  REWARD_SOURCE_TYPE_RESIDENT_UPGRADE_STAR = 95
};
SGPROTOBUF_API bool RewardSourceType_IsValid(int value);
constexpr RewardSourceType RewardSourceType_MIN = REWARD_SOURCE_TYPE_NONE;
constexpr RewardSourceType RewardSourceType_MAX = REWARD_SOURCE_TYPE_RESIDENT_UPGRADE_STAR;
constexpr int RewardSourceType_ARRAYSIZE = RewardSourceType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewardSourceType_descriptor();
template<typename T>
inline const std::string& RewardSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewardSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewardSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RewardSourceType_descriptor(), enum_t_value);
}
inline bool RewardSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RewardSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RewardSourceType>(
    RewardSourceType_descriptor(), name, value);
}
enum RewardNtfType : int {
  REWARD_NTF_IGNORE = -1,
  REWARD_NTF_DEFAULT = 0,
  REWARD_NTF_DAILY_TASK = 1,
  REWARD_NTF_MAIN_TASK = 2,
  REWARD_NTF_BRANCH_TASK = 3,
  REWARD_NTF_CAMPAIGN = 4,
  REWARD_NTF_MAIL = 5,
  REWARD_NTF_USE_ITEM = 6,
  REWARD_NTF_CHAPTER_TASK = 7,
  REWARD_NTF_NOTES = 8,
  REWARD_NTF_GAME_EVENT = 9,
  REWARD_NTF_SHELTER_CHAPTER = 10,
  REWARD_NTF_REVERT = 11,
  REWARD_NTF_TIP = 12,
  REWARD_NTF_COST = 13,
  REWARD_NTF_NOTE_TASK = 14,
  REWARD_NTF_RESOURCE = 15,
  REWARD_NTF_EXPLORE_LEVELUP = 16,
  REWARD_NTF_DECREE = 17,
  REWARD_NTF_AREA_GRID = 18,
  REWARD_NTF_RECYCLE_DEVICE = 19,
  REWARD_NTF_LIMIT_MATCH = 20,
  REWARD_NTF_MONSTER_AWARD = 21,
  REWARD_NTF_SPEEDUP_RETURN = 22,
  REWARD_NTF_EXPLORE_COMPLETE_REWARD = 23
};
SGPROTOBUF_API bool RewardNtfType_IsValid(int value);
constexpr RewardNtfType RewardNtfType_MIN = REWARD_NTF_IGNORE;
constexpr RewardNtfType RewardNtfType_MAX = REWARD_NTF_EXPLORE_COMPLETE_REWARD;
constexpr int RewardNtfType_ARRAYSIZE = RewardNtfType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewardNtfType_descriptor();
template<typename T>
inline const std::string& RewardNtfType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewardNtfType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewardNtfType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RewardNtfType_descriptor(), enum_t_value);
}
inline bool RewardNtfType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RewardNtfType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RewardNtfType>(
    RewardNtfType_descriptor(), name, value);
}
enum LanguageType : int {
  LANGUAGE_TYPE_NONE = 0,
  LANGUAGE_TYPE_ENG = 180000001,
  LANGUAGE_TYPE_originalwords = 180000002,
  LANGUAGE_TYPE_CHT = 180000003,
  LANGUAGE_TYPE_FR = 180000004,
  LANGUAGE_TYPE_DE = 180000005,
  LANGUAGE_TYPE_JP = 180000006,
  LANGUAGE_TYPE_IT = 180000007,
  LANGUAGE_TYPE_PL = 180000008,
  LANGUAGE_TYPE_RU = 180000009,
  LANGUAGE_TYPE_TH = 180000010,
  LANGUAGE_TYPE_ES = 180000011,
  LANGUAGE_TYPE_IND = 180000012,
  LANGUAGE_TYPE_PT = 180000013,
  LANGUAGE_TYPE_TR = 180000014,
  LANGUAGE_TYPE_VN = 180000015,
  LANGUAGE_TYPE_KR = 180000016,
  LANGUAGE_TYPE_ARB = 180000017
};
SGPROTOBUF_API bool LanguageType_IsValid(int value);
constexpr LanguageType LanguageType_MIN = LANGUAGE_TYPE_NONE;
constexpr LanguageType LanguageType_MAX = LANGUAGE_TYPE_ARB;
constexpr int LanguageType_ARRAYSIZE = LanguageType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguageType_descriptor();
template<typename T>
inline const std::string& LanguageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguageType_descriptor(), enum_t_value);
}
inline bool LanguageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguageType>(
    LanguageType_descriptor(), name, value);
}
enum PackCase : int {
  USE_LIMIT_MAX = 10000
};
SGPROTOBUF_API bool PackCase_IsValid(int value);
constexpr PackCase PackCase_MIN = USE_LIMIT_MAX;
constexpr PackCase PackCase_MAX = USE_LIMIT_MAX;
constexpr int PackCase_ARRAYSIZE = PackCase_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PackCase_descriptor();
template<typename T>
inline const std::string& PackCase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PackCase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PackCase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PackCase_descriptor(), enum_t_value);
}
inline bool PackCase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PackCase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PackCase>(
    PackCase_descriptor(), name, value);
}
enum RecruitType : int {
  RECRUIT_TYPE_SINGLE = 1,
  RECRUIT_TYPE_LOT = 2
};
SGPROTOBUF_API bool RecruitType_IsValid(int value);
constexpr RecruitType RecruitType_MIN = RECRUIT_TYPE_SINGLE;
constexpr RecruitType RecruitType_MAX = RECRUIT_TYPE_LOT;
constexpr int RecruitType_ARRAYSIZE = RecruitType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecruitType_descriptor();
template<typename T>
inline const std::string& RecruitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecruitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecruitType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecruitType_descriptor(), enum_t_value);
}
inline bool RecruitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecruitType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecruitType>(
    RecruitType_descriptor(), name, value);
}
enum BannerType : int {
  BANNER_TYPE_PRIMARY = 1,
  BANNER_TYPE_SENIOR = 2
};
SGPROTOBUF_API bool BannerType_IsValid(int value);
constexpr BannerType BannerType_MIN = BANNER_TYPE_PRIMARY;
constexpr BannerType BannerType_MAX = BANNER_TYPE_SENIOR;
constexpr int BannerType_ARRAYSIZE = BannerType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BannerType_descriptor();
template<typename T>
inline const std::string& BannerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BannerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BannerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BannerType_descriptor(), enum_t_value);
}
inline bool BannerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BannerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BannerType>(
    BannerType_descriptor(), name, value);
}
enum ShopType : int {
  SHOP_TYPE_NONE = 0,
  SHOP_TYPE_ALLIANCE = 1
};
SGPROTOBUF_API bool ShopType_IsValid(int value);
constexpr ShopType ShopType_MIN = SHOP_TYPE_NONE;
constexpr ShopType ShopType_MAX = SHOP_TYPE_ALLIANCE;
constexpr int ShopType_ARRAYSIZE = ShopType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShopType_descriptor();
template<typename T>
inline const std::string& ShopType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShopType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShopType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShopType_descriptor(), enum_t_value);
}
inline bool ShopType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShopType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShopType>(
    ShopType_descriptor(), name, value);
}
enum ShopRefreshType : int {
  SHOP_REFRESH_TYPE_NONE = 0,
  SHOP_REFRESH_TYPE_WEEKLY = 1,
  SHOP_REFRESH_TYPE_DAILY = 2,
  SHOP_REFRESH_TYPE_Hours = 3
};
SGPROTOBUF_API bool ShopRefreshType_IsValid(int value);
constexpr ShopRefreshType ShopRefreshType_MIN = SHOP_REFRESH_TYPE_NONE;
constexpr ShopRefreshType ShopRefreshType_MAX = SHOP_REFRESH_TYPE_Hours;
constexpr int ShopRefreshType_ARRAYSIZE = ShopRefreshType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShopRefreshType_descriptor();
template<typename T>
inline const std::string& ShopRefreshType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShopRefreshType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShopRefreshType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShopRefreshType_descriptor(), enum_t_value);
}
inline bool ShopRefreshType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShopRefreshType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShopRefreshType>(
    ShopRefreshType_descriptor(), name, value);
}
enum RecruitFreeType : int {
  RECRUIT_FREE_NONE = 0,
  RECRUIT_FREE_GENERAL_SINGLE = 1,
  RECRUIT_FREE_GENERAL_LOT = 2,
  RECRUIT_FREE_SENIOR_SINGLE = 3,
  RECRUIT_FREE_SENIOR_LOT = 4
};
SGPROTOBUF_API bool RecruitFreeType_IsValid(int value);
constexpr RecruitFreeType RecruitFreeType_MIN = RECRUIT_FREE_NONE;
constexpr RecruitFreeType RecruitFreeType_MAX = RECRUIT_FREE_SENIOR_LOT;
constexpr int RecruitFreeType_ARRAYSIZE = RecruitFreeType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecruitFreeType_descriptor();
template<typename T>
inline const std::string& RecruitFreeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecruitFreeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecruitFreeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecruitFreeType_descriptor(), enum_t_value);
}
inline bool RecruitFreeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecruitFreeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecruitFreeType>(
    RecruitFreeType_descriptor(), name, value);
}
enum MonsterType : int {
  MONSTER_TYPE_NONE = 0,
  MONSTER_TYPE_NORMAL = 1,
  MONSTER_TYPE_ASSEMBLE = 2,
  MONSTER_TYPE_NPC_TOWN_GUARDER = 3,
  MONSTER_TYPE_EXPLORE_MONSTER = 4,
  MONSTER_TYPE_DOOMSDAY_MONSTER = 101,
  MONSTER_TYPE_DOOMSDAY_BOSS = 102,
  MONSTER_TYPE_ASSEMBLE_ACTIVITY = 103,
  MONSTER_TYPE_WP_CALL_MONSTER_ACTIVITY = 104,
  MONSTER_TYPE_ALLIANCE = 105,
  MONSTER_TYPE_BR_NORMAL = 106,
  MONSTER_TYPE_BR_SENIOR = 107,
  MONSTER_TYPE_WORLD_BOSS = 108
};
SGPROTOBUF_API bool MonsterType_IsValid(int value);
constexpr MonsterType MonsterType_MIN = MONSTER_TYPE_NONE;
constexpr MonsterType MonsterType_MAX = MONSTER_TYPE_WORLD_BOSS;
constexpr int MonsterType_ARRAYSIZE = MonsterType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MonsterType_descriptor();
template<typename T>
inline const std::string& MonsterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MonsterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MonsterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MonsterType_descriptor(), enum_t_value);
}
inline bool MonsterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MonsterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MonsterType>(
    MonsterType_descriptor(), name, value);
}
enum ResourcePointType : int {
  RESOURCE_POINT_TYPE_NONE = 0,
  RESOURCE_POINT_TYPE_NORMAL = 1,
  RESOURCE_POINT_TYPE_INCIDENT = 2
};
SGPROTOBUF_API bool ResourcePointType_IsValid(int value);
constexpr ResourcePointType ResourcePointType_MIN = RESOURCE_POINT_TYPE_NONE;
constexpr ResourcePointType ResourcePointType_MAX = RESOURCE_POINT_TYPE_INCIDENT;
constexpr int ResourcePointType_ARRAYSIZE = ResourcePointType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourcePointType_descriptor();
template<typename T>
inline const std::string& ResourcePointType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourcePointType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourcePointType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourcePointType_descriptor(), enum_t_value);
}
inline bool ResourcePointType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourcePointType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourcePointType>(
    ResourcePointType_descriptor(), name, value);
}
enum MarkType : int {
  MARK_TYPE_NONE = 0,
  MARK_TYPE_SPECIAL = 1,
  MARK_TYPE_FRIEND = 2,
  MARK_TYPE_ENEMY = 3,
  MARK_TYPE_ALLIANCE = 4
};
SGPROTOBUF_API bool MarkType_IsValid(int value);
constexpr MarkType MarkType_MIN = MARK_TYPE_NONE;
constexpr MarkType MarkType_MAX = MARK_TYPE_ALLIANCE;
constexpr int MarkType_ARRAYSIZE = MarkType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarkType_descriptor();
template<typename T>
inline const std::string& MarkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarkType_descriptor(), enum_t_value);
}
inline bool MarkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarkType>(
    MarkType_descriptor(), name, value);
}
enum HeroStatus : int {
  HERO_STATUS_NONE = 0,
  HERO_STATUS_MARCHING = 1,
  HERO_STATUS_GARRISON = 2
};
SGPROTOBUF_API bool HeroStatus_IsValid(int value);
constexpr HeroStatus HeroStatus_MIN = HERO_STATUS_NONE;
constexpr HeroStatus HeroStatus_MAX = HERO_STATUS_GARRISON;
constexpr int HeroStatus_ARRAYSIZE = HeroStatus_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HeroStatus_descriptor();
template<typename T>
inline const std::string& HeroStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeroStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeroStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HeroStatus_descriptor(), enum_t_value);
}
inline bool HeroStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeroStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HeroStatus>(
    HeroStatus_descriptor(), name, value);
}
enum HeroSkillType : int {
  HERO_SKILL_TYPE_NONE = 0,
  HERO_SKILL_TYPE_ONE = 1,
  HERO_SKILL_TYPE_TWO = 2,
  HERO_SKILL_TYPE_THREE = 3,
  HERO_SKILL_TYPE_FOUR = 4
};
SGPROTOBUF_API bool HeroSkillType_IsValid(int value);
constexpr HeroSkillType HeroSkillType_MIN = HERO_SKILL_TYPE_NONE;
constexpr HeroSkillType HeroSkillType_MAX = HERO_SKILL_TYPE_FOUR;
constexpr int HeroSkillType_ARRAYSIZE = HeroSkillType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HeroSkillType_descriptor();
template<typename T>
inline const std::string& HeroSkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeroSkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeroSkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HeroSkillType_descriptor(), enum_t_value);
}
inline bool HeroSkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeroSkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HeroSkillType>(
    HeroSkillType_descriptor(), name, value);
}
enum LoginModeType : int {
  LOGIN_MODULE_SELF = 0,
  LOGIN_MODULE_SDK_PAPPUS = 1,
  LOGIN_MODULE_IGG_SDK = 2,
  LOGIN_MODULE_FACEBOOK = 6,
  LOGIN_MODULE_LOCAL_ACCOUNT = 12,
  LOGIN_MODULE_MI = 13
};
SGPROTOBUF_API bool LoginModeType_IsValid(int value);
constexpr LoginModeType LoginModeType_MIN = LOGIN_MODULE_SELF;
constexpr LoginModeType LoginModeType_MAX = LOGIN_MODULE_MI;
constexpr int LoginModeType_ARRAYSIZE = LoginModeType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginModeType_descriptor();
template<typename T>
inline const std::string& LoginModeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginModeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginModeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginModeType_descriptor(), enum_t_value);
}
inline bool LoginModeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginModeType>(
    LoginModeType_descriptor(), name, value);
}
enum KICK_PLAYER_TYPE : int {
  KICK_PLAYER_TYPE_DEFAULT = -1,
  KICK_PLAYER_TYPE_ONLINE_ALREADY = 0,
  KICK_PLAYER_TYPE_DISCONNECT_LONGTIME = 1,
  KICK_PLAYER_TYPE_CLIENT_REQ_OFFLINE = 2,
  KICK_PLAYER_TYPE_HEALTH_INVALID = 3,
  KICK_PLAYER_TYPE_BGIP_PROC = 4,
  KICK_PLAYER_TYPE_SHUT_SERVER = 5,
  KICK_PLAYER_TYPE_ZK_OFF_LINE_ALL_PLAYER = 6,
  KICK_PLAYER_TYPE_SERVER_ERROR = 7,
  KICK_PLAYER_TYPE_GM = 8,
  KICK_PLAYER_TYPE_GATETOKENERROR = 9,
  KICK_PLAYER_TYPE_GATE_RECONNECT = 10
};
SGPROTOBUF_API bool KICK_PLAYER_TYPE_IsValid(int value);
constexpr KICK_PLAYER_TYPE KICK_PLAYER_TYPE_MIN = KICK_PLAYER_TYPE_DEFAULT;
constexpr KICK_PLAYER_TYPE KICK_PLAYER_TYPE_MAX = KICK_PLAYER_TYPE_GATE_RECONNECT;
constexpr int KICK_PLAYER_TYPE_ARRAYSIZE = KICK_PLAYER_TYPE_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KICK_PLAYER_TYPE_descriptor();
template<typename T>
inline const std::string& KICK_PLAYER_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KICK_PLAYER_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KICK_PLAYER_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KICK_PLAYER_TYPE_descriptor(), enum_t_value);
}
inline bool KICK_PLAYER_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KICK_PLAYER_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KICK_PLAYER_TYPE>(
    KICK_PLAYER_TYPE_descriptor(), name, value);
}
enum PlatformType : int {
  PLATFORMTYPE_ANDRIOD = 0,
  PLATFORMTYPE_IOS = 1
};
SGPROTOBUF_API bool PlatformType_IsValid(int value);
constexpr PlatformType PlatformType_MIN = PLATFORMTYPE_ANDRIOD;
constexpr PlatformType PlatformType_MAX = PLATFORMTYPE_IOS;
constexpr int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlatformType_descriptor();
template<typename T>
inline const std::string& PlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlatformType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlatformType_descriptor(), enum_t_value);
}
inline bool PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlatformType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlatformType>(
    PlatformType_descriptor(), name, value);
}
enum WorldType : int {
  WORLDTYPE_WEBCHAT = 1,
  WORLDTYPE_QQ = 2,
  WORLDTYPE_TEST = 3
};
SGPROTOBUF_API bool WorldType_IsValid(int value);
constexpr WorldType WorldType_MIN = WORLDTYPE_WEBCHAT;
constexpr WorldType WorldType_MAX = WORLDTYPE_TEST;
constexpr int WorldType_ARRAYSIZE = WorldType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldType_descriptor();
template<typename T>
inline const std::string& WorldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldType_descriptor(), enum_t_value);
}
inline bool WorldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldType>(
    WorldType_descriptor(), name, value);
}
enum PlatformWorldType : int {
  PLATFORM_WORLD_ANDROID = 0,
  PLATFORM_WORLD_IOS = 1
};
SGPROTOBUF_API bool PlatformWorldType_IsValid(int value);
constexpr PlatformWorldType PlatformWorldType_MIN = PLATFORM_WORLD_ANDROID;
constexpr PlatformWorldType PlatformWorldType_MAX = PLATFORM_WORLD_IOS;
constexpr int PlatformWorldType_ARRAYSIZE = PlatformWorldType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlatformWorldType_descriptor();
template<typename T>
inline const std::string& PlatformWorldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlatformWorldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlatformWorldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlatformWorldType_descriptor(), enum_t_value);
}
inline bool PlatformWorldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlatformWorldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlatformWorldType>(
    PlatformWorldType_descriptor(), name, value);
}
enum CrossState : int {
  CROSSSTATE_OUT = 0,
  CROSSSTATE_IN = 1
};
SGPROTOBUF_API bool CrossState_IsValid(int value);
constexpr CrossState CrossState_MIN = CROSSSTATE_OUT;
constexpr CrossState CrossState_MAX = CROSSSTATE_IN;
constexpr int CrossState_ARRAYSIZE = CrossState_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CrossState_descriptor();
template<typename T>
inline const std::string& CrossState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrossState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrossState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CrossState_descriptor(), enum_t_value);
}
inline bool CrossState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrossState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CrossState>(
    CrossState_descriptor(), name, value);
}
enum BigAreaType : int {
  BIGAREAID_NONE = -1,
  BIGAREAID_All = 0,
  BIGAREAID_WEBCHAT_IOS = 1,
  BIGAREAID_WEBCHAT_ANDROID = 2,
  BIGAREAID_QQ_IOS = 3,
  BIGAREAID_QQ_ANDROID = 4,
  BIGAREAID_TEST = 99
};
SGPROTOBUF_API bool BigAreaType_IsValid(int value);
constexpr BigAreaType BigAreaType_MIN = BIGAREAID_NONE;
constexpr BigAreaType BigAreaType_MAX = BIGAREAID_TEST;
constexpr int BigAreaType_ARRAYSIZE = BigAreaType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BigAreaType_descriptor();
template<typename T>
inline const std::string& BigAreaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BigAreaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BigAreaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BigAreaType_descriptor(), enum_t_value);
}
inline bool BigAreaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BigAreaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BigAreaType>(
    BigAreaType_descriptor(), name, value);
}
enum BGIP_CMD_ERRORItemType_OfflineExp : int {
  CMD_ERROR_LOADCHAR = -16,
  CMD_ERROR_SAVECHAR = -15,
  CMD_ERROR_DECODING = -14,
  CMD_ERROR_NOYBP = -13,
  CMD_ERROR_BGIP = -12,
  CMD_ERROR_CONFIGURATION = -11,
  CMD_ERROR_SERVICE_UNKOWN = -10,
  CMD_ERROR_SYSTEM_BUSY = -9,
  CMD_ERROR_SYSTEM = -8,
  CMD_ERROR_NONEOBJECT = -7,
  CMD_ERROR_OTHER = -6,
  CMD_ERROR_BUSY = -5,
  CMD_ERROR_API = -4,
  CMD_ERROR_DB = -3,
  CMD_ERROR_TIMEOUT = -2,
  CMD_ERROR_NET = -1,
  CMD_SUCCESS = 0,
  CMD_SUCCESS_NOBODY = 1,
  CMD_OPENIDWRONG = 2,
  CMD_ORDER_REPEAT = 3,
  CMD_NUMBER_ERROR = 4,
  CMD_COMMON_REPEAT = 5,
  CMD_OBJECT_NOT_EXIST = 6,
  CMD_REPEATED_DEAL = 7
};
SGPROTOBUF_API bool BGIP_CMD_ERRORItemType_OfflineExp_IsValid(int value);
constexpr BGIP_CMD_ERRORItemType_OfflineExp BGIP_CMD_ERRORItemType_OfflineExp_MIN = CMD_ERROR_LOADCHAR;
constexpr BGIP_CMD_ERRORItemType_OfflineExp BGIP_CMD_ERRORItemType_OfflineExp_MAX = CMD_REPEATED_DEAL;
constexpr int BGIP_CMD_ERRORItemType_OfflineExp_ARRAYSIZE = BGIP_CMD_ERRORItemType_OfflineExp_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BGIP_CMD_ERRORItemType_OfflineExp_descriptor();
template<typename T>
inline const std::string& BGIP_CMD_ERRORItemType_OfflineExp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BGIP_CMD_ERRORItemType_OfflineExp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BGIP_CMD_ERRORItemType_OfflineExp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BGIP_CMD_ERRORItemType_OfflineExp_descriptor(), enum_t_value);
}
inline bool BGIP_CMD_ERRORItemType_OfflineExp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BGIP_CMD_ERRORItemType_OfflineExp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BGIP_CMD_ERRORItemType_OfflineExp>(
    BGIP_CMD_ERRORItemType_OfflineExp_descriptor(), name, value);
}
enum GenderType : int {
  GenderType_None = 0,
  GenderType_Male = 1,
  GenderType_Female = 2
};
SGPROTOBUF_API bool GenderType_IsValid(int value);
constexpr GenderType GenderType_MIN = GenderType_None;
constexpr GenderType GenderType_MAX = GenderType_Female;
constexpr int GenderType_ARRAYSIZE = GenderType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GenderType_descriptor();
template<typename T>
inline const std::string& GenderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GenderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GenderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GenderType_descriptor(), enum_t_value);
}
inline bool GenderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GenderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GenderType>(
    GenderType_descriptor(), name, value);
}
enum EServerState : int {
  EST_CRASH = 0,
  EST_NORMAL = 1,
  EST_BUSY = 2,
  EST_FIRE = 3,
  EST_MAINTEN = 4
};
SGPROTOBUF_API bool EServerState_IsValid(int value);
constexpr EServerState EServerState_MIN = EST_CRASH;
constexpr EServerState EServerState_MAX = EST_MAINTEN;
constexpr int EServerState_ARRAYSIZE = EServerState_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EServerState_descriptor();
template<typename T>
inline const std::string& EServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EServerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EServerState_descriptor(), enum_t_value);
}
inline bool EServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EServerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EServerState>(
    EServerState_descriptor(), name, value);
}
enum EImigrantState : int {
  ETS_Close = 0,
  ETS_Open = 1,
  ETS_NORMAL = 3
};
SGPROTOBUF_API bool EImigrantState_IsValid(int value);
constexpr EImigrantState EImigrantState_MIN = ETS_Close;
constexpr EImigrantState EImigrantState_MAX = ETS_NORMAL;
constexpr int EImigrantState_ARRAYSIZE = EImigrantState_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EImigrantState_descriptor();
template<typename T>
inline const std::string& EImigrantState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EImigrantState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EImigrantState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EImigrantState_descriptor(), enum_t_value);
}
inline bool EImigrantState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EImigrantState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EImigrantState>(
    EImigrantState_descriptor(), name, value);
}
enum PowerMode : int {
  PM_UNKNOW = 0,
  PM_WEIXIN = 1,
  PM_SQGAMECENTER = 2,
  PM_IOSVISITOR = 3
};
SGPROTOBUF_API bool PowerMode_IsValid(int value);
constexpr PowerMode PowerMode_MIN = PM_UNKNOW;
constexpr PowerMode PowerMode_MAX = PM_IOSVISITOR;
constexpr int PowerMode_ARRAYSIZE = PowerMode_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerMode_descriptor();
template<typename T>
inline const std::string& PowerMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerMode_descriptor(), enum_t_value);
}
inline bool PowerMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerMode>(
    PowerMode_descriptor(), name, value);
}
enum ESdkTimeProcType : int {
  ESdkTimeProcTypeOnlieTimeSet = 1,
  ESdkTimeProcTypeTryTimeSet = 2
};
SGPROTOBUF_API bool ESdkTimeProcType_IsValid(int value);
constexpr ESdkTimeProcType ESdkTimeProcType_MIN = ESdkTimeProcTypeOnlieTimeSet;
constexpr ESdkTimeProcType ESdkTimeProcType_MAX = ESdkTimeProcTypeTryTimeSet;
constexpr int ESdkTimeProcType_ARRAYSIZE = ESdkTimeProcType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESdkTimeProcType_descriptor();
template<typename T>
inline const std::string& ESdkTimeProcType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESdkTimeProcType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESdkTimeProcType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESdkTimeProcType_descriptor(), enum_t_value);
}
inline bool ESdkTimeProcType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESdkTimeProcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESdkTimeProcType>(
    ESdkTimeProcType_descriptor(), name, value);
}
enum MsgTip : int {
  EGEC_SUCCESS = 0,
  EGEC_UNKOWN_ERROR = 1,
  EGEC_NONE = 2,
  EGEC_PARSE_MSG_ERROR = 3,
  EGEC_NO_MSG_HANDLER = 4,
  EGEC_MSG_ROUTER_REQUEST_ERROR = 5,
  EGEC_MSG_ROUTER_REPLY_ERROR = 6,
  EGEC_PLAYER_NOT_FIND = 7,
  EGEC_PLAYER_IS_NULL = 8,
  EGEC_RECORD_NOT_FIND = 9,
  EGEC_RECORD_IS_NULL = 10,
  EGEC_SERVER_ERROR = 11,
  EGEC_SIGNATURE_SUCCES = 21,
  EGEC_ACCOUNTPWD_INVALID = 22,
  EGEC_ACCOUNT_INVALID = 23,
  EGEC_ACCOUNT_USING = 24,
  EGEC_ACCOUNT_LOCKED = 25,
  EGEC_CHARACTER_EXIST = 26,
  EGEC_CHARACTER_SUCCESS = 27,
  EGEC_CHARACTER_FAILD = 28,
  EGEC_DELETECHAR_SUCCESS = 29,
  EGEC_DELETECHAR_FAILD = 30,
  EGEC_CHARACTER_NUMOUT = 31,
  EGEC_CHARACTER_INVALID = 32,
  EGEC_CHARACTER_NOTEXIST = 33,
  EGEC_CHARACTER_USING = 34,
  EGEC_CHARACTER_LOCKED = 35,
  EGEC_REACH_REGISTER_LIMITS = 36,
  EGEC_CREATE_CHAR_TOO_MANY = 37,
  EGEC_CREATE_CHAR_NAME_TOO_LONG = 38,
  EGEC_CREATE_CHAR_LIMIT = 39,
  EGEC_CREATE_CHAR_NAME_VALID = 40,
  EGEC_CREATE_CHAR_NAME_TOO_SHORT = 41,
  EGEC_SVRZONEID_INVALID = 42,
  EGEC_THIS_AREA_IS_CLOSING = 43,
  EGEC_FORBIDDEN_LOG_HEALTH_VALID = 44,
  EGEC_ENTERGAME_SUCCESS = 51,
  EGEC_ENTERGAME_FAILD = 52,
  EGEC_NO_GATEWAY = 71,
  EGEC_MachineForbid = 72,
  EGEC_ACCOUNT_NOTALLOW = 81,
  EGEC_ACCOUNT_BGIP_NOPLAY = 82,
  EGEC_VERSION_NOT_MATCH = 101,
  EGEC_NO_LOGINSERVER = 102,
  EGEC_SERVER_MAINTEN = 103,
  EGEC_SERVER_NO_REVIEW = 104,
  EGEC_VERSION_IS_GRAYVERSION = 105,
  EGEC_VERSION_CANT_GRAYVERSION = 106,
  EGEC_SERVER_INVALID = 107,
  EGEC_LOGIN_DEQUEUE = 108,
  EGEC_LOGIN_IN_QUEUE = 109,
  EGEC_BAN_KICKOUT = 110,
  EGEC_NEED_RELOGIN = 111,
  EGEC_GAMESERVER_DISCONNECT = 112,
  EGEC_ENTER_SCENE_SUCCESS = 113,
  EGEC_ENTER_SCENE_FAIL = 114,
  EGEC_SHOW_TEXT_AND_DO_NEXT = 115,
  EGEC_LOGIN_NOFUND_CLIENT_CACHE_INFO = 116,
  EGEC_LOGIN_SERVERID_INVALID = 117,
  EGEC_LOGIN_NO_SAME_RECONNECT_ROLEID = 118,
  EGEC_LOGIN_ROLE_BAN = 119,
  EGEC_CLENT_SEND_MSG_ERR = 120,
  EGEC_GATE_TOKEN_ERROR_KICK = 121,
  EGEC_GATE_CONFIGCLIENTID_ERROR_KICK = 122,
  EGEC_TX_COMSUME_MONEY_FAILED = 501,
  EGEC_HASHSLOT_FOLLOWER_ALREADY_ADD = 2700,
  EGEC_HASHSLOT_CANNOT_UPDATE_WITH_CRASHED_NODE = 2701,
  EGEC_HASHSLOT_HAVE_NO_FOLLOWER = 2702,
  EGEC_HASHSLOT_FOLLOWER_NOT_FIND = 2703,
  EGEC_HASHSLOT_NOT_FIND_SELF_IN_FOLLOWER_MAP = 2704,
  EGEC_HASHSLOT_TOTAL_SLOT_CNT_CANNOT_CHANGE = 2705,
  EGEC_HASHSLOT_NOT_FIND_GUID_IN_SLOT_LIST = 2706,
  EGEC_HASHSLOT_GUID_CANNOT_ADD_THIS_FOLLOWER = 2707,
  EGEC_HASHSLOT_OBSERVER_VER_BIGGER_THAN_FOLLOWER = 2708,
  EGEC_HASHSLOT_TOTAL_HASHSLOT_INFO_NOT_FIND = 2709,
  EGEC_HASHSLOT_TOTAL_HASHSLOT_INFO_OUT_OF_DATE = 2710,
  EGEC_CITY_BUILDING_LEVELUP_SUCCESS = 5001,
  EGEC_TACTICAL_BUILDING_IN_FIGHT = 5002,
  EGEC_TACTICAL_BUILDING_RESOURSE_NOT_ENOUGHT = 5003,
  EGEC_TACTICAL_BUILDING_ITEM_NOT_ENOUGHT = 5004,
  EGEC_DATA_ERROR = 10001,
  EGEC_FUNC_IS_LOCKED = 10002,
  EGEC_LEVEL_NOT_SATISFIED = 10003,
  EGEC_AWARD_DRAWN = 10004,
  EGEC_SERVER_LEVEL_NOT_ENOUGH = 10005,
  EGEC_ACTIVITY_DISABLED = 10006,
  EGEC_ACTIVITY_NOT_START = 10007,
  EGEC_ACTIVITY_EXPIRED = 10008,
  EGEC_VERSION_CANT_USE_ITEM = 10009,
  EGEC_NOT_MEET_CONDITION = 10010,
  EGEC_SHORT_TIME_TOO_MUCH_MSG = 10011,
  EGEC_GAIN_REWARD_FAILED = 10012,
  EGEC_HAVE_BLOCK_WORDS = 10013,
  EGEC_NOT_ENOUGH_CURENCY = 10014,
  EGEC_IN_CD = 10015,
  EGEC_UNEXPECTED_VALUE = 10016,
  EGEC_TIME_NOT_MEET = 10017,
  EGEC_BAD_PARAMS = 10018,
  EGEC_NOT_ENOUGH_ITEM = 10019,
  EGEC_GM_COMMAND_NOT_EXIST = 10020,
  EGEC_BAD_ITEM_TYPE = 10021,
  EGEC_USE_BOX_CHOOSE_INVALID_COUNT = 10022,
  EGEC_ALREADY_GET_REWARD = 10023,
  EGEC_NOTE_GAMEID = 10024,
  EGEC_ALLIANCE_LEADER_RECYCLE = 10025,
  EGEC_NO_SUIT_POS_FOR_CALL_MONSTER = 10026,
  EGEC_HAS_ALLIANCE = 10027,
  EGEC_IS_TOWN_OFFICIAL = 10028,
  EGEC_IS_EXIST_SOLDIER_IS_CHUZHENG_CAN_NOT_TEAM = 10029,
  EGEC_IS_EXIST_CAN_NOT_FAQI_MUNCH_TEAM = 10030,
  EGEC_IS_EXIST_SOLDIER_GROUP_CAN_NOT_AGIN = 10031,
  EGEC_IS_EXIST_ALLIANCE_ATTACKED = 10032,
  EGEC_IS_TEAM_KILL_TARGET_GET_REWARD = 10033,
  EGEC_IS_TEAM_IS_FULL = 10034,
  EGEC_IS_TEAM_MONSTER_LEVEL_NOT_UNLOCK = 10035,
  EGEC_ASSEMBLE_SG_BE_KICKED = 10036,
  EGEC_ASSEMBLE_SG_MARCHING = 10037,
  EGEC_USE_CALL_MONSTER_ITEM_IN_CROSSAREA = 10038,
  EGEC_BUILDING_ALREADY_EXIST = 11001,
  EGEC_BAD_BUILDING_TYPE = 11002,
  EGEC_CHECK_PRECONDITIONS_FAILED = 11003,
  EGEC_NO_WORKER = 11004,
  EGEC_BUILDING_NOT_EXIST = 11005,
  EGEC_BUILDING_MAX_LEVEL = 11006,
  EGEC_BUILDING_CANNOT_LVUP = 11007,
  EGEC_BUILDING_ALREADY_UPGRADE = 11008,
  EGEC_INVAILD_WORKER = 11009,
  EGEC_BAD_WORKER = 11010,
  EGEC_BAD_BUILDING = 11011,
  EGEC_BAD_BUILDING_LEVEL = 11012,
  EGEC_BUILDING_NOT_UPGRADE = 11013,
  EGEC_BAD_BUILDING_STATUS = 11014,
  EGEC_MAX_WALL_HP = 11015,
  EGEC_BAD_BUILDING_CLASSIFICATION = 11016,
  EGEC_BAD_WOUNDED_NUM = 11017,
  EGEC_HAS_CURING = 11018,
  EGEC_HAS_NO_CURING = 11019,
  EGEC_HAS_TRAINING = 11020,
  EGEC_HAS_NO_TRAINING = 11021,
  EGEC_BAD_TRAIN_SOLDIER = 11022,
  EGEC_MAX_TRAIN_NUM = 11023,
  EGEC_BAD_PROMOTE_DATA = 11024,
  EGEC_SHELTER_ALREADY_UNLOCK = 11025,
  EGEC_SHELTER_NOT_UNLOCK = 11026,
  EGEC_SHELTER_BAD_PROGRESS = 11027,
  EGEC_SHELTER_HAS_BUILDING = 11028,
  EGEC_HAS_STUDYING = 11029,
  EGEC_HAS_NO_STUDYING = 11030,
  EGEC_ALREADY_HAS_TECH = 11031,
  EGEC_CHECK_PRETECH_FAILED = 11032,
  EGEC_FINISH_TECH_FAILED = 11033,
  EGEC_FURNITURE_NOT_EXIST = 11034,
  EGEC_FURNITURE_NOT_ENOUGH = 11035,
  EGEC_BUILDING_LEVEL_NOT_ENOUGH = 11036,
  EGEC_FURNITURE_ALREADY_EXIST = 11037,
  EGEC_MAX_SOLDIER_TYPE_NUM = 11038,
  EGEC_SOLDIER_CAPACITY_NOT_ENOUGH = 11039,
  EGEC_MAX_SOLDIER_TYPE_NUM_MAIL_TAKE = 11040,
  EGEC_MAX_SOLDIER_TYPE_NUM_MAIL_TAKE_LIMITED = 11041,
  EGEC_DRESSUP_EMOJI_IN_CD = 11042,
  EGEC_DRESSUP_EMOJI_NOT_UNLOCK = 11043,
  EGEC_SHIELD_EXIST_BETTER = 11045,
  EGEC_SGLIST_OUTSIDE = 11081,
  EGEC_CITY_IN_BATTLE = 11082,
  EGEC_CITY_MOVE_FAILED = 11083,
  EGEC_SET_DGNVIEW_NOT_IN_DUNGEON = 11084,
  EGEC_ALREADY_IN_DUNGEON = 11085,
  EGEC_CITY_MOVE_ALLIANCE_NO_TERRITORY = 11086,
  EGEC_CITY_SOLDIER_NOT_ENOUGH = 11101,
  EGEC_NOVICE_PROTECT_ATTACK = 11102,
  EGEC_CACEL_TEAM_FOR_TIMEOUT = 11103,
  EGEC_CACEL_TEAM_FOR_TARGET_DISAPEAR = 11104,
  EGEC_CACEL_TEAM_FOR_LOSE = 11105,
  EGEC_SHARE_TEAM_ATTACK_SUCCESS = 11106,
  EGEC_BLACK_LIMIT = 11111,
  EGEC_FRIEND_LIMIT = 11112,
  EGEC_APPLY_LIMIT = 11113,
  EGEC_APPLY_ME_LIMIT = 11114,
  EGEC_OTHER_FRIEND_LIMIT = 11115,
  EGEC_ALREADY_FINISHED_TASK = 11121,
  EGEC_NOT_ENOUGH_TASK_PROGRESS = 11122,
  EGEC_DUPLICATE_PLAYER_NAME = 11131,
  EGEC_ALREADY_HAS_DRESS_UP = 11132,
  EGEC_DIRTY_WORLD = 11133,
  EGEC_RESONATE_SLOT_LOCK = 11900,
  EGEC_RESONATE_SLOT_USED = 11901,
  EGEC_RESONATE_HERO_SETED = 11902,
  EGEC_RESONATE_SLOT_CD = 11903,
  EGEC_RESONATE_HERO_NOT_EXIST = 11904,
  EGEC_RESONATE_HERO_LEADER = 11905,
  EGEC_RESONATE_SLOT_NO_HERO = 11906,
  EGEC_RESONATE_SLOT_UNLOCKED = 11907,
  EGEC_RESONATE_SLOT_CD_CLEARED = 11908,
  EGEC_EQUIP_LEVEL_CFG_NOT_FOUND = 11910,
  EGEC_EQUIP_RISE_LEVEL_NOT_ENOUGH = 11911,
  EGEC_EQUIP_UPGRADE_LEVEL_NOT_ENOUGH = 11912,
  EGEC_HERO_NOT_EXIST = 11913,
  EGEC_EQUIP_NOT_MATCH_HERO = 11914,
  EGEC_EQUIP_NOT_ENOUGH = 11915,
  EGEC_EQUIP_CAN_NOT_RECAST = 11916,
  EGEC_EQUIP_QUALITY_DIFF = 11917,
  EGEC_EQUIP_QUALITY_NOT_FOUND = 11918,
  EGEC_EQUIP_NOT_FOUND = 11919,
  EGEC_EQUIP_HERO_STATUS_NOT_ALLOW = 11920,
  EGEC_EQUIP_BAG_FULL = 11921,
  EGEC_DISPATCH_INVALID_HERO = 11950,
  EGEC_DISPATCH_HERO_UESD = 11951,
  EGEC_DISPATCH_HERO_CONDITION = 11952,
  EGEC_DISPATCH_REFRESH_NOT_ENOUGH = 11953,
  EGEC_DISPATCH_REFRESH_NOT_NEED = 11954,
  EGEC_DISPATCH_HELP_LIMIT = 11955,
  EGEC_DISPATCH_NOT_EXIST = 11956,
  EGEC_DISPATCH_DONE = 11957,
  EGEC_DISPATCH_ROB_DAILY_LIMIT = 11958,
  EGEC_DISPATCH_ROB_LIMIT = 11959,
  EGEC_DISPATCH_ROB_REPEAT = 11960,
  EGEC_DISPATCH_HELP_REPEAT = 11961,
  EGEC_DISPATCH_HELPED = 11962,
  EGEC_HERO_STORY_STAR_UNLOCK = 12000,
  EGEC_HERO_STORY_AWARD_DRAWN = 12001,
  EGEC_HERO_UP_SKILL_NEED_HERO_LV = 12002,
  EGEC_HERO_UP_SKILL_COST_NOT_ENOUGH = 12003,
  EGEC_HERO_UP_SKILL_NOT_FOUND = 12004,
  EGEC_HERO_NOT_UNLOCK = 12005,
  EGEC_HERO_UP_EQUIP_NEED_HERO_LV = 12006,
  EGEC_HERO_UP_STAR_COST_NOT_ENOUGH = 12010,
  EGEC_HERO_CUR_STAR_LEVEL_MAX = 12015,
  EGEC_HERO_COST_FRAGMENT_EXISTS = 12016,
  EGEC_HERO_COST_FRAGMENT_NOT_ENOUGHT = 12017,
  EGEC_HERO_UP_TALENT_UNLOCK = 12020,
  EGEC_HERO_UP_TALENT_NOT_ENOUGH = 12021,
  EGEC_HERO_UP_TALENT_NOT_FOUND = 12022,
  EGEC_HERO_UP_TALENT_MAX_LV = 12023,
  EGEC_HERO_UP_TALENT_HERO_LV_LIMIT = 12024,
  EGEC_HERO_RESET_TALENT_COST_NOT_ENOUGH = 12025,
  EGEC_ALLIANCE_HAS_UNPROCESSED_APPLICATION = 12026,
  EGEC_ALLIANCE_NAME_LEN_INVALID = 12027,
  EGEC_ALLIANCE_NAME_REPETITION = 12028,
  EGEC_ALLIANCE_TAG_LEN_INVALID = 12029,
  EGEC_ALLIANCE_SHOP_ITEM_EXPIRE = 12030,
  EGEC_ALLIANCE_REPLACE_LEADER_ERROR = 12031,
  EGEC_ALLIANCE_SCHEDULE_LIMIT = 12032,
  EGEC_ALLIANCE_WELCOME_ROOKIEALLIANCE = 12033,
  EGEC_ALLIANCE_CAN_NOT_JOIN_OTHER_SERVER = 12034,
  EGEC_BUILDING_GARRISON_SOLDIERGROUP_LIMIT = 12035,
  EGEC_BUILDING_GARRISON_CITY_LIMIT = 12036,
  EGEC_BUILDING_GARRISON_SOLDIER_LIMIT = 12037,
  EGEC_GARRISON_ENEMY_BUILDING = 12038,
  EGEC_ATTACK_ALLIANCE_BUILDING_WITHOUT_ALLIANCE = 12039,
  EGEC_ATTACK_ALLIANCE_BUILDING_NOT_LINK = 12040,
  EGEC_ALLIANCE_NOT_FIND = 12041,
  EGEC_ALLIANCE_MOVE_CITY_ERROR = 12042,
  EGEC_GARRISON_LEADER_CHANGE = 12043,
  EGEC_GARRISON_KICKED_OUT = 12044,
  EGEC_QUIT_ALLIANCE_FAILED_BY_NPC_TOWN = 12045,
  EGEC_ALLIANCE_CAN_NOT_JOIN = 12047,
  EGEC_ALLIANCE_APPLY_CD = 12048,
  EGEC_ALLIANCE_CAN_NOT_APPOINT = 12049,
  EGEC_BUILDING_IN_SOLDIER_LIMIT = 12050,
  EGEC_MARCHING_ENERGY_NOT_ENOUGH = 12052,
  EGEC_CHARGE_BAG_TIME_LIMIT = 12053,
  EGEC_ALLIANCE_ROOKIE_MOVE_NO_PLACE = 12054,
  EGEC_ALLIANCE_PLAYER_ALREADY_QUIT = 12055,
  EGEC_ALLIANCE_MOBILIZATION_NO_ALLIANCE = 12056,
  EGEC_ALLIANCE_MOBILIZATION_JOIN_OTHER = 12057,
  EGEC_ALLIANCE_MOBILIZATION_MEMBER_COUNT = 12058,
  EGEC_ALLIANCE_MOBILIZATION_REFRESH_CD = 12059,
  EGEC_ALLIANCE_MOBILIZATION_CLAIM_ERROR = 12060,
  EGEC_ALLIANCE_CAN_NOT_DISBAND = 12061,
  EGEC_ALLIANCE_MOBILIZATION_GOTO_BIND = 12062,
  EGEC_ALLIANCE_MOBILIZATION_LV_LIMIT = 12063,
  EGEC_ALLIANCE_MOBILIZATION_NO_MATCH = 12064,
  EGEC_ALLIANCE_MOBILIZATION_NOT_OPEN = 12065,
  EGEC_ALLIANCE_POSITION_LV_LIMIT = 12066,
  EGEC_ALLIANCE_MOVE_NIL_POS = 12067,
  EGEC_ALLIANCE_MOVE_ITEM_LCAK = 12068,
  EGEC_ALLIANCE_JOIN_SGLIST_OUTSIDE = 12069,
  EGEC_ALLIANCE_GET_REWARD_BOX_TOP = 12070,
  EGEC_ALLIANCE_OTHER_MEMBER_SET_BOSS_INFO = 12071,
  EGEC_ALLIANCE_FAST_JOIN_ALLIANCE_NIL = 12075,
  EGEC_ALLIANCE_LEADER_ONLINE = 12076,
  EGEC_ALLIANCE_LEADER_CHANGE = 12077,
  EGEC_ALLIANCE_CASTLE_LV_LIMIT = 12078,
  EGEC_ALLIANCE_MEMBER_LIMIT = 12079,
  EGEC_ALLIANCE_APPLY_REFUSE = 12080,
  EGEC_VIP_DAILY_EXP = 12101,
  EGEC_VIP_PAY_PACK = 12102,
  EGEC_VIP_LEVEL_NOT_ENOUGH = 12103,
  EGEC_VIP_FREE_PACK = 12104,
  EGEC_VIP_BUY_VIP_EXP = 12105,
  EGEC_ENERGY_NOT_ENOUGH = 12106,
  EGEC_DAILY_CHARGE_LIMIT = 12107,
  EGEC_RPG_DUNGEON_CHEAT_ERROR = 12108,
  EGEC_MIGRATING = 12111,
  EGEC_MIGRATE_SAME_AREA = 12112,
  EGEC_BAD_MIGRATE_TYPE = 12113,
  EGEC_MIGRATE_AREA_TOO_NEW = 12114,
  EGEC_MIGRATE_RANK_LIMIT = 12115,
  EGEC_MIGRATE_AREA_JOIN_LIMIT = 12116,
  EGEC_MIGRATE_FUNCTION_CLOSE = 12117,
  EGEC_ARENA_NOT_SET_SOLDIERS = 12131,
  EGEC_ARENA_ATTEMPTS_NOT_ENOUGH = 12132,
  EGEC_ARENA_TARGET_RECYCLE = 12133,
  EGEC_ARENA_SETTLEING = 12134,
  EGEC_ATTACK_NPC_TOWN_WITHOUT_ALLIANCE = 14001,
  EGEC_NPC_TOWN_LINK_ERROR = 14003,
  EGEC_KING_KILL_BAD_TARGET = 14004,
  EGEC_NPC_TOWN_DECLARE_WAR_ERROR = 14005,
  EGEC_NPC_TOWN_PROTECT_ERROR = 14006,
  EGEC_NPC_TOWN_DECLARE_WAR_MEMBER_LIMIT = 14007,
  EGEC_NPC_TOWN_DECLARE_WAR_NEED_NEAR = 14008,
  EGEC_NPC_TOWN_OCCUPY_FULL = 14009,
  EGEC_NPC_TOWN_DECLARE_WAR_LEVEL_LIMIT = 14010,
  EGEC_EXPLORE_RADAR_FULL = 14300,
  EGEC_RESIDENTS_NOT_IN_CURE = 15001,
  EGEC_RESIDENTS_LOW_ELEC = 15002,
  EGEC_RESIDENTS_OVER_ELEC_CAPACITY = 15003,
  EGEC_BATTLE_REPORT_INVALID = 16001,
  EGEC_BATTLE_WIN = 16002,
  EGEC_BATTLE_LOG_INVALID = 16003,
  EGEC_ESCORT_UNLOCK = 17001,
  EGEC_ESCORT_UNLOCK_SLOT = 17002,
  EGEC_ESCORT_ESCORTING_REFRESH = 17003,
  EGEC_ESCORT_REFRESH_COST_ID = 17004,
  EGEC_ESCORT_NOT_FIND_CAR = 17005,
  EGEC_ESCORT_ROB_SELF_ALLIANCE = 17006,
  EGEC_ESCORT_BE_ROB_MAX = 17007,
  EGEC_WORLDBOSS_MAX_ATTACK_COUNT = 17008,
  EGEC_ALLIANCE_DULE_SETTLEING = 17100,
  EGEC_ALLIANCE_DULE_CROSS_AREA_CD = 17101,
  EGEC_ALLIANCE_DULE_NO_RIVAL = 17103,
  EGEC_CHAT_DATA_EXPIRED = 17201
};
SGPROTOBUF_API bool MsgTip_IsValid(int value);
constexpr MsgTip MsgTip_MIN = EGEC_SUCCESS;
constexpr MsgTip MsgTip_MAX = EGEC_CHAT_DATA_EXPIRED;
constexpr int MsgTip_ARRAYSIZE = MsgTip_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgTip_descriptor();
template<typename T>
inline const std::string& MsgTip_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgTip>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgTip_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgTip_descriptor(), enum_t_value);
}
inline bool MsgTip_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgTip* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgTip>(
    MsgTip_descriptor(), name, value);
}
enum SdkMsgTip : int {
  SMT_SUCCESS = 0
};
SGPROTOBUF_API bool SdkMsgTip_IsValid(int value);
constexpr SdkMsgTip SdkMsgTip_MIN = SMT_SUCCESS;
constexpr SdkMsgTip SdkMsgTip_MAX = SMT_SUCCESS;
constexpr int SdkMsgTip_ARRAYSIZE = SdkMsgTip_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdkMsgTip_descriptor();
template<typename T>
inline const std::string& SdkMsgTip_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SdkMsgTip>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SdkMsgTip_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SdkMsgTip_descriptor(), enum_t_value);
}
inline bool SdkMsgTip_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SdkMsgTip* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SdkMsgTip>(
    SdkMsgTip_descriptor(), name, value);
}
enum EAwardSource : int {
  AWARD_SOURCE_DEFAULT = 0,
  AWARD_SOURCE_DECOMPOSE = 1
};
SGPROTOBUF_API bool EAwardSource_IsValid(int value);
constexpr EAwardSource EAwardSource_MIN = AWARD_SOURCE_DEFAULT;
constexpr EAwardSource EAwardSource_MAX = AWARD_SOURCE_DECOMPOSE;
constexpr int EAwardSource_ARRAYSIZE = EAwardSource_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAwardSource_descriptor();
template<typename T>
inline const std::string& EAwardSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAwardSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAwardSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAwardSource_descriptor(), enum_t_value);
}
inline bool EAwardSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAwardSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAwardSource>(
    EAwardSource_descriptor(), name, value);
}
enum ELReason : int {
  ELREASON_GM_ADD_ITEM = 1
};
SGPROTOBUF_API bool ELReason_IsValid(int value);
constexpr ELReason ELReason_MIN = ELREASON_GM_ADD_ITEM;
constexpr ELReason ELReason_MAX = ELREASON_GM_ADD_ITEM;
constexpr int ELReason_ARRAYSIZE = ELReason_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELReason_descriptor();
template<typename T>
inline const std::string& ELReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELReason_descriptor(), enum_t_value);
}
inline bool ELReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELReason>(
    ELReason_descriptor(), name, value);
}
enum EBClassification : int {
  CASTLE = 1,
  GUARD_HOUSE = 2,
  BUILD_ATOWER = 3,
  SABER_BARRACK = 5,
  RIDER_BARRACK = 6,
  ARCHER_BARRACK = 7,
  HOSPITAL = 11,
  FOOD_FACTORY = 13,
  WOOD_FACTORY = 14,
  IRON_FACTORY = 15,
  OIL_FACTORY = 16,
  TECH = 17,
  RECRUIT = 20,
  RESIDENT_CABIN = 100,
  CANTEEN = 101,
  RESCUE_CENTER = 102
};
SGPROTOBUF_API bool EBClassification_IsValid(int value);
constexpr EBClassification EBClassification_MIN = CASTLE;
constexpr EBClassification EBClassification_MAX = RESCUE_CENTER;
constexpr int EBClassification_ARRAYSIZE = EBClassification_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBClassification_descriptor();
template<typename T>
inline const std::string& EBClassification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBClassification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBClassification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBClassification_descriptor(), enum_t_value);
}
inline bool EBClassification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBClassification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBClassification>(
    EBClassification_descriptor(), name, value);
}
enum EBStatus : int {
  INACTIVE = -1,
  FREE = 0,
  ON_FIRE = 1,
  CURING = 2,
  TRAINING = 3,
  STUDYING = 4,
  UPGRADING = 5,
  CREATING = 6,
  STUDYING_EXT = 7
};
SGPROTOBUF_API bool EBStatus_IsValid(int value);
constexpr EBStatus EBStatus_MIN = INACTIVE;
constexpr EBStatus EBStatus_MAX = STUDYING_EXT;
constexpr int EBStatus_ARRAYSIZE = EBStatus_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBStatus_descriptor();
template<typename T>
inline const std::string& EBStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBStatus_descriptor(), enum_t_value);
}
inline bool EBStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBStatus>(
    EBStatus_descriptor(), name, value);
}
enum ESoldierSource : int {
  SS_UNKNOWN = 0,
  SS_HOSPITAL = 1,
  SS_BARRACK = 2,
  SS_BARRACK_CANCEL = 3,
  SS_TATICALBUILDING = 4,
  SS_ITEM_GIVE = 5
};
SGPROTOBUF_API bool ESoldierSource_IsValid(int value);
constexpr ESoldierSource ESoldierSource_MIN = SS_UNKNOWN;
constexpr ESoldierSource ESoldierSource_MAX = SS_ITEM_GIVE;
constexpr int ESoldierSource_ARRAYSIZE = ESoldierSource_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESoldierSource_descriptor();
template<typename T>
inline const std::string& ESoldierSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESoldierSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESoldierSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESoldierSource_descriptor(), enum_t_value);
}
inline bool ESoldierSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESoldierSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESoldierSource>(
    ESoldierSource_descriptor(), name, value);
}
enum EChannel : int {
  CL_AREA = 1,
  CL_ALLIANCE = 2,
  CL_GROUP = 3,
  CL_PLAYER = 4,
  CL_NEW_HAND = 5,
  CL_LANGUAGE = 6,
  CL_ALLIANCE_R4 = 7,
  CL_ALLIANCE_NOTICE = 8,
  CL_MAX = 9
};
SGPROTOBUF_API bool EChannel_IsValid(int value);
constexpr EChannel EChannel_MIN = CL_AREA;
constexpr EChannel EChannel_MAX = CL_MAX;
constexpr int EChannel_ARRAYSIZE = EChannel_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EChannel_descriptor();
template<typename T>
inline const std::string& EChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EChannel_descriptor(), enum_t_value);
}
inline bool EChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EChannel>(
    EChannel_descriptor(), name, value);
}
enum EMoveTye : int {
  MT_SENIOR = 1,
  MT_RANDOM = 2,
  MT_ALLIANCE = 3,
  MT_NEW_HAND = 4,
  MT_BURN_DOWN = 5,
  MT_BORN = 6,
  MT_FORCE_RANDOM = 7,
  MT_ALLIANCE_ROOKIE = 8,
  MT_GM = 9,
  MT_JOIN_ALLIANCE = 10,
  MT_CREATE_ALLIANCE = 11,
  MT_ALLIANCE_LEADER = 12,
  MT_ALLIANCE_FREE = 13,
  MT_MAX = 14
};
SGPROTOBUF_API bool EMoveTye_IsValid(int value);
constexpr EMoveTye EMoveTye_MIN = MT_SENIOR;
constexpr EMoveTye EMoveTye_MAX = MT_MAX;
constexpr int EMoveTye_ARRAYSIZE = EMoveTye_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMoveTye_descriptor();
template<typename T>
inline const std::string& EMoveTye_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMoveTye>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMoveTye_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EMoveTye_descriptor(), enum_t_value);
}
inline bool EMoveTye_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EMoveTye* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EMoveTye>(
    EMoveTye_descriptor(), name, value);
}
enum ESceneType : int {
  EScene_Invalid = 0,
  EScene_Main = 1,
  EScene_Race = 2,
  EScene_NewHand = 3,
  EScene_ClientNewbeeDungeon = 4,
  EScene_DungeonServer = 5,
  EScene_Arena = 6
};
SGPROTOBUF_API bool ESceneType_IsValid(int value);
constexpr ESceneType ESceneType_MIN = EScene_Invalid;
constexpr ESceneType ESceneType_MAX = EScene_Arena;
constexpr int ESceneType_ARRAYSIZE = ESceneType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESceneType_descriptor();
template<typename T>
inline const std::string& ESceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESceneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESceneType_descriptor(), enum_t_value);
}
inline bool ESceneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESceneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESceneType>(
    ESceneType_descriptor(), name, value);
}
enum EBroadcastRangeType : int {
  ERange_All = 1,
  ERange_Alliance = 2
};
SGPROTOBUF_API bool EBroadcastRangeType_IsValid(int value);
constexpr EBroadcastRangeType EBroadcastRangeType_MIN = ERange_All;
constexpr EBroadcastRangeType EBroadcastRangeType_MAX = ERange_Alliance;
constexpr int EBroadcastRangeType_ARRAYSIZE = EBroadcastRangeType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastRangeType_descriptor();
template<typename T>
inline const std::string& EBroadcastRangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastRangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastRangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastRangeType_descriptor(), enum_t_value);
}
inline bool EBroadcastRangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastRangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastRangeType>(
    EBroadcastRangeType_descriptor(), name, value);
}
enum EBroadcastType : int {
  EBroadcast_OccupyNeuTralCity = 219000001,
  EBroadcast_AppointOfficial = 219000002,
  EBroadcast_OtherAreaCityComeIn = 219002013
};
SGPROTOBUF_API bool EBroadcastType_IsValid(int value);
constexpr EBroadcastType EBroadcastType_MIN = EBroadcast_OccupyNeuTralCity;
constexpr EBroadcastType EBroadcastType_MAX = EBroadcast_OtherAreaCityComeIn;
constexpr int EBroadcastType_ARRAYSIZE = EBroadcastType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastType_descriptor();
template<typename T>
inline const std::string& EBroadcastType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastType_descriptor(), enum_t_value);
}
inline bool EBroadcastType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastType>(
    EBroadcastType_descriptor(), name, value);
}
enum EEquipMaterialsOperateType : int {
  EOperate_Produce = 1,
  EOperate_StopProduce = 2,
  EOperate_Synthesis = 3,
  EOperate_Decompose = 4
};
SGPROTOBUF_API bool EEquipMaterialsOperateType_IsValid(int value);
constexpr EEquipMaterialsOperateType EEquipMaterialsOperateType_MIN = EOperate_Produce;
constexpr EEquipMaterialsOperateType EEquipMaterialsOperateType_MAX = EOperate_Decompose;
constexpr int EEquipMaterialsOperateType_ARRAYSIZE = EEquipMaterialsOperateType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEquipMaterialsOperateType_descriptor();
template<typename T>
inline const std::string& EEquipMaterialsOperateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EEquipMaterialsOperateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EEquipMaterialsOperateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EEquipMaterialsOperateType_descriptor(), enum_t_value);
}
inline bool EEquipMaterialsOperateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EEquipMaterialsOperateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EEquipMaterialsOperateType>(
    EEquipMaterialsOperateType_descriptor(), name, value);
}
enum EPlayerDataRefreshType : int {
  PDRT_NONE = 0,
  PDRT_WEEKLY = 1,
  PDRT_DAILY = 2
};
SGPROTOBUF_API bool EPlayerDataRefreshType_IsValid(int value);
constexpr EPlayerDataRefreshType EPlayerDataRefreshType_MIN = PDRT_NONE;
constexpr EPlayerDataRefreshType EPlayerDataRefreshType_MAX = PDRT_DAILY;
constexpr int EPlayerDataRefreshType_ARRAYSIZE = EPlayerDataRefreshType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPlayerDataRefreshType_descriptor();
template<typename T>
inline const std::string& EPlayerDataRefreshType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPlayerDataRefreshType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPlayerDataRefreshType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPlayerDataRefreshType_descriptor(), enum_t_value);
}
inline bool EPlayerDataRefreshType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPlayerDataRefreshType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPlayerDataRefreshType>(
    EPlayerDataRefreshType_descriptor(), name, value);
}
enum EHttpAddItemSourceType : int {
  EHAIST_None = 0,
  EHAIST_Activity = 1,
  EHAIST_VIP = 2,
  EHAIST_PUSH_GIFT = 3,
  EHAIST_DOLLAR_TOKEN = 4
};
SGPROTOBUF_API bool EHttpAddItemSourceType_IsValid(int value);
constexpr EHttpAddItemSourceType EHttpAddItemSourceType_MIN = EHAIST_None;
constexpr EHttpAddItemSourceType EHttpAddItemSourceType_MAX = EHAIST_DOLLAR_TOKEN;
constexpr int EHttpAddItemSourceType_ARRAYSIZE = EHttpAddItemSourceType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHttpAddItemSourceType_descriptor();
template<typename T>
inline const std::string& EHttpAddItemSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHttpAddItemSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHttpAddItemSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHttpAddItemSourceType_descriptor(), enum_t_value);
}
inline bool EHttpAddItemSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHttpAddItemSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHttpAddItemSourceType>(
    EHttpAddItemSourceType_descriptor(), name, value);
}
enum ETaskBigType : int {
  ETaskBigType_None = 0,
  ETaskBigType_Main = 1,
  ETaskBigType_Branch = 2,
  ETaskBigType_Chapter = 3,
  ETaskBigType_Daily = 4
};
SGPROTOBUF_API bool ETaskBigType_IsValid(int value);
constexpr ETaskBigType ETaskBigType_MIN = ETaskBigType_None;
constexpr ETaskBigType ETaskBigType_MAX = ETaskBigType_Daily;
constexpr int ETaskBigType_ARRAYSIZE = ETaskBigType_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETaskBigType_descriptor();
template<typename T>
inline const std::string& ETaskBigType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETaskBigType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETaskBigType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETaskBigType_descriptor(), enum_t_value);
}
inline bool ETaskBigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETaskBigType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETaskBigType>(
    ETaskBigType_descriptor(), name, value);
}
enum EGender : int {
  EGender_None = 0,
  EGender_Male = 1,
  EGender_Female = 2
};
SGPROTOBUF_API bool EGender_IsValid(int value);
constexpr EGender EGender_MIN = EGender_None;
constexpr EGender EGender_MAX = EGender_Female;
constexpr int EGender_ARRAYSIZE = EGender_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGender_descriptor();
template<typename T>
inline const std::string& EGender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGender_descriptor(), enum_t_value);
}
inline bool EGender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGender>(
    EGender_descriptor(), name, value);
}
enum MailID : int {
  MAILID_REWARD_MAX = 197204001
};
SGPROTOBUF_API bool MailID_IsValid(int value);
constexpr MailID MailID_MIN = MAILID_REWARD_MAX;
constexpr MailID MailID_MAX = MAILID_REWARD_MAX;
constexpr int MailID_ARRAYSIZE = MailID_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailID_descriptor();
template<typename T>
inline const std::string& MailID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailID_descriptor(), enum_t_value);
}
inline bool MailID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailID>(
    MailID_descriptor(), name, value);
}
enum ESpecialTaskData : int {
  STD_CalcParamDiffScore = 1
};
SGPROTOBUF_API bool ESpecialTaskData_IsValid(int value);
constexpr ESpecialTaskData ESpecialTaskData_MIN = STD_CalcParamDiffScore;
constexpr ESpecialTaskData ESpecialTaskData_MAX = STD_CalcParamDiffScore;
constexpr int ESpecialTaskData_ARRAYSIZE = ESpecialTaskData_MAX + 1;

SGPROTOBUF_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESpecialTaskData_descriptor();
template<typename T>
inline const std::string& ESpecialTaskData_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESpecialTaskData>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESpecialTaskData_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESpecialTaskData_descriptor(), enum_t_value);
}
inline bool ESpecialTaskData_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESpecialTaskData* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESpecialTaskData>(
    ESpecialTaskData_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace SGDefine

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SGDefine::ZKServerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ZKServerType>() {
  return ::SGDefine::ZKServerType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::server_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::server_type>() {
  return ::SGDefine::server_type_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ItemResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ItemResourceType>() {
  return ::SGDefine::ItemResourceType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::HeroBelongType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::HeroBelongType>() {
  return ::SGDefine::HeroBelongType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ItemSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ItemSubType>() {
  return ::SGDefine::ItemSubType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::RewardSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::RewardSourceType>() {
  return ::SGDefine::RewardSourceType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::RewardNtfType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::RewardNtfType>() {
  return ::SGDefine::RewardNtfType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::LanguageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::LanguageType>() {
  return ::SGDefine::LanguageType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::PackCase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::PackCase>() {
  return ::SGDefine::PackCase_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::RecruitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::RecruitType>() {
  return ::SGDefine::RecruitType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::BannerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::BannerType>() {
  return ::SGDefine::BannerType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ShopType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ShopType>() {
  return ::SGDefine::ShopType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ShopRefreshType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ShopRefreshType>() {
  return ::SGDefine::ShopRefreshType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::RecruitFreeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::RecruitFreeType>() {
  return ::SGDefine::RecruitFreeType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::MonsterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::MonsterType>() {
  return ::SGDefine::MonsterType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ResourcePointType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ResourcePointType>() {
  return ::SGDefine::ResourcePointType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::MarkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::MarkType>() {
  return ::SGDefine::MarkType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::HeroStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::HeroStatus>() {
  return ::SGDefine::HeroStatus_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::HeroSkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::HeroSkillType>() {
  return ::SGDefine::HeroSkillType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::LoginModeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::LoginModeType>() {
  return ::SGDefine::LoginModeType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::KICK_PLAYER_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::KICK_PLAYER_TYPE>() {
  return ::SGDefine::KICK_PLAYER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::PlatformType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::PlatformType>() {
  return ::SGDefine::PlatformType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::WorldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::WorldType>() {
  return ::SGDefine::WorldType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::PlatformWorldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::PlatformWorldType>() {
  return ::SGDefine::PlatformWorldType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::CrossState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::CrossState>() {
  return ::SGDefine::CrossState_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::BigAreaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::BigAreaType>() {
  return ::SGDefine::BigAreaType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::BGIP_CMD_ERRORItemType_OfflineExp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::BGIP_CMD_ERRORItemType_OfflineExp>() {
  return ::SGDefine::BGIP_CMD_ERRORItemType_OfflineExp_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::GenderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::GenderType>() {
  return ::SGDefine::GenderType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EServerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EServerState>() {
  return ::SGDefine::EServerState_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EImigrantState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EImigrantState>() {
  return ::SGDefine::EImigrantState_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::PowerMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::PowerMode>() {
  return ::SGDefine::PowerMode_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ESdkTimeProcType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ESdkTimeProcType>() {
  return ::SGDefine::ESdkTimeProcType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::MsgTip> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::MsgTip>() {
  return ::SGDefine::MsgTip_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::SdkMsgTip> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::SdkMsgTip>() {
  return ::SGDefine::SdkMsgTip_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EAwardSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EAwardSource>() {
  return ::SGDefine::EAwardSource_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ELReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ELReason>() {
  return ::SGDefine::ELReason_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EBClassification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EBClassification>() {
  return ::SGDefine::EBClassification_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EBStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EBStatus>() {
  return ::SGDefine::EBStatus_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ESoldierSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ESoldierSource>() {
  return ::SGDefine::ESoldierSource_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EChannel>() {
  return ::SGDefine::EChannel_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EMoveTye> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EMoveTye>() {
  return ::SGDefine::EMoveTye_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ESceneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ESceneType>() {
  return ::SGDefine::ESceneType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EBroadcastRangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EBroadcastRangeType>() {
  return ::SGDefine::EBroadcastRangeType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EBroadcastType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EBroadcastType>() {
  return ::SGDefine::EBroadcastType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EEquipMaterialsOperateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EEquipMaterialsOperateType>() {
  return ::SGDefine::EEquipMaterialsOperateType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EPlayerDataRefreshType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EPlayerDataRefreshType>() {
  return ::SGDefine::EPlayerDataRefreshType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EHttpAddItemSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EHttpAddItemSourceType>() {
  return ::SGDefine::EHttpAddItemSourceType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ETaskBigType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ETaskBigType>() {
  return ::SGDefine::ETaskBigType_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::EGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::EGender>() {
  return ::SGDefine::EGender_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::MailID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::MailID>() {
  return ::SGDefine::MailID_descriptor();
}
template <> struct is_proto_enum< ::SGDefine::ESpecialTaskData> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SGDefine::ESpecialTaskData>() {
  return ::SGDefine::ESpecialTaskData_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SGDefine_2eproto
